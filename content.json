{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"HeavenBin","url":"http://blog.heavenbin.live"},"pages":[{"title":"关于","date":"2018-09-29T08:22:36.000Z","updated":"2018-09-02T18:35:44.000Z","comments":false,"path":"about/index.html","permalink":"http://blog.heavenbin.live/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2018-09-29T08:22:36.000Z","updated":"2018-09-02T18:35:44.000Z","comments":false,"path":"books/index.html","permalink":"http://blog.heavenbin.live/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-09-29T08:22:36.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"categories/index.html","permalink":"http://blog.heavenbin.live/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-09-29T08:22:36.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"links/index.html","permalink":"http://blog.heavenbin.live/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-09-29T08:22:36.000Z","updated":"2018-09-02T18:35:44.000Z","comments":false,"path":"repository/index.html","permalink":"http://blog.heavenbin.live/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-09-29T08:22:36.000Z","updated":"2018-09-02T18:35:44.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.heavenbin.live/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"多页面Webpack4脚手架","slug":"多页面Webpack脚手架","date":"2018-08-16T16:00:00.000Z","updated":"2018-09-30T08:38:27.000Z","comments":true,"path":"2018/08/17/多页面Webpack脚手架/","link":"","permalink":"http://blog.heavenbin.live/2018/08/17/多页面Webpack脚手架/","excerpt":"","text":"前言：在开发中当遇到多页面项目时需要对应的自动化编译工具，所以针对多页面应用制作了一款webpack脚手架。供给大家互相学习，有什么疑问可以issues我。源码地址：https://github.com/HeavenBin/WebpackTemplate项目构成 ├── build // webpack配置目录 │ ├── utils.js // 工具文件 │ ├── config.js // 配置文件 │ ├── webpack.config.base.js // 基础构建 │ ├── webpack.config.dev.js // 开发模式构建 │ ├── webpack.config.prod.js // 生产模式构建 ├── dist // 生产目录 ├── src // 开发目录 ├── .babelrc // babel配置 ├── .editorconfig // editorconfig配置 ├── .eslintignore // eslint排除的检测范围 ├── .eslintrc.js // eslint配置 ├── postcss.config.js // postcss配置 技术栈Webpack4：现代 JavaScript 应用程序的静态模块打包器 (自动化构建工具)editorconfig：编辑器样式风格的统一配置 (统一代码风格工具)eslint：JavaScript和JSX检查工具 (TS/ES代码语法检测)babel：JavaScript 语法转换器 (TS/ES代码转换器)postcss: 使用JavaScript转换CSS的工具 (CSS预处理平台)支持各种CSS扩展语言的转化及压缩：css、less、sass、stylus支持各种格式文件的预处理以及压缩：文字类、图片类、影音类之后还会加入: 单元测试、端对端测试、…使用说明需要NodeJS环境、git环境，我所使用的版本：node v10.1.0 npm 6.3.0克隆库到本地HTTPS方式： git clone https://github.com/HeavenBin/WebpackTemplate.gitSSH方式：git clone git@github.com:HeavenBin/WebpackTemplate.gitcd WebpackTemplate 进入项目目录打开build/config.js文件根据自身要求进行自定义设置123456789101112131415161718192021222324252627282930313233343536const config = &#123; projectPath: utils.resolve('/'), // 项目根目录 srcPath: utils.resolve('/src/'), // 源文件目录 node_modulesPath: utils.resolve('/node_modules/'), // node_modules目录 htmlPath: utils.resolve('/src/'), // HTML目录 jsPath: utils.resolve('/src/main/'), // JS目录 ignoreJs: ['test'], // 没有入口js文件的html名 assetsSubDirectory: utils.resolve('/src/static/'), // 静态资源目录(不处理的第三方代码) dev: &#123; host: 'localhost', port: '3002', useEslint: false, // 是否使用ESlint showEslintErrorsInOverlay: true, // 设置为true，ESlint-loader将始终返回警告。 devSourceMap: false, // 是否开启SourceMap devtool: 'eval-source-map', assetsPublicPath: '/', // 相对于服务器根目录的路径，用于加载资源。 proxyTable: &#123; // proxy代理 '/api': 'http://localhost:3000' &#125; &#125;, build: &#123; prodSourceMap: false, // 是否开启SourcMap devtool: 'source-map', assetsRoot: path.resolve(__dirname, '../dist'), // 构建根目录 assetsPublicPath: '/' // 相对于服务器根目录的路径，用于加载构建好的资源。 &#125;&#125;npm run build 构建dist生产目录npm run dev 构建热更新服务开始进行开发","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://blog.heavenbin.live/categories/Webpack/"}],"tags":[{"name":"多页面","slug":"多页面","permalink":"http://blog.heavenbin.live/tags/多页面/"},{"name":"脚手架","slug":"脚手架","permalink":"http://blog.heavenbin.live/tags/脚手架/"}]},{"title":"使用纯原生JS造轮子(不依赖任何框架)","slug":"使用纯原生JS造轮子(不依赖任何框架)","date":"2018-05-14T16:00:00.000Z","updated":"2018-09-03T09:00:52.000Z","comments":true,"path":"2018/05/15/使用纯原生JS造轮子(不依赖任何框架)/","link":"","permalink":"http://blog.heavenbin.live/2018/05/15/使用纯原生JS造轮子(不依赖任何框架)/","excerpt":"","text":"前言：从原生JS入手,构造常用的工具库以及常见的场景插件。供给大家互相学习，有什么疑问可以issues我。源码地址：https://github.com/HeavenBin/JsWheels使用原生JS构造常用的工具库以及常见的场景插件,俗称造轮子!不用任何框架、预编译，用最笨的办法造轮子使用最新 JS 语法编写预览https://heavenbin.github.io/JsWheels/进度部分BOM部分DOMTab切换栏分页插件运行git clone https://github.com/HeavenBin/JsWheels.gitcd JsWheels浏览器 打开 index.html","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.heavenbin.live/categories/JavaScript/"}],"tags":[{"name":"原生造轮子","slug":"原生造轮子","permalink":"http://blog.heavenbin.live/tags/原生造轮子/"}]},{"title":"基于vue2+vuex+vue-router+sass+webpack的网易云音乐","slug":"基于vue2+vuex+vue-router+sass+webpack的网易云音乐","date":"2018-03-16T16:00:00.000Z","updated":"2018-09-03T08:56:53.000Z","comments":true,"path":"2018/03/17/基于vue2+vuex+vue-router+sass+webpack的网易云音乐/","link":"","permalink":"http://blog.heavenbin.live/2018/03/17/基于vue2+vuex+vue-router+sass+webpack的网易云音乐/","excerpt":"","text":"前言：这段时间写的一个项目，供给大家互相学习，有什么疑问可以issues我。源码地址：https://github.com/HeavenBin/VueMusic项目构成 ├── build // webpack配置文件 ├── config // 不同环境的打包配置 ├── dist // 生产目录 ├── index.html // 入口html文件 ├── package.json // 项目配置文件 ├── static // 放置静态资源 ├── src // 开发目录 │ ├── pages // 页面 │ ├── components // 组件 │ ├── config // 基本配置 │ ├── images // 公共图片 │ ├── plugins // 引用插件 │ ├── router // 路由配置 │ ├── service // 数据交互 │ ├── store // vuex状态管理 │ ├── style // 公共样式 │ ├── App.vue // 页面入口文件 │ └── main.js // 程序入口文件 技术栈 Vue2： 采用现代渐进式框架Vue2的版本 Vuex： 管理公共组件状态量 vue-router： 管理单页面应用路由 自定义ajax： 基于xmlhttprequest对象以及新兴Fetch对象结合封装的http请求 CSS3： CSS3动画及样式。 Sass： CSS预处理语言。 Webpack： 自动化构建工具，主要配置vue-cli脚手架提供。 ES6： 采用ES6语法。 SVG： 基于可扩展标记语言的可缩放矢量图形。 接口来源(感谢Binaryify不断更新的网易云音乐接口)","categories":[{"name":"Vue","slug":"Vue","permalink":"http://blog.heavenbin.live/categories/Vue/"}],"tags":[{"name":"音乐播放器","slug":"音乐播放器","permalink":"http://blog.heavenbin.live/tags/音乐播放器/"}]},{"title":"JavaScript模块化的演变","slug":"JavaScript模块化的演变","date":"2018-01-17T17:26:25.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2018/01/18/JavaScript模块化的演变/","link":"","permalink":"http://blog.heavenbin.live/2018/01/18/JavaScript模块化的演变/","excerpt":"","text":"函数封装123function name()&#123; statement&#125;缺点&emsp;污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。对象12345678var myModule = &#123; var1: 1, var2: 2, fn1: function()&#123; &#125;, fn2: function()&#123; &#125;&#125;优点&emsp;避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系。缺点1myModele.var1 = 100;&emsp;&emsp;这样就会产生意外的安全问题立即执行函数(模块化的基础)123456789101112var myModule = (function()&#123; var var1 = 1; var var2 = 2; function fn1()&#123; &#125; function fn2()&#123; &#125; return &#123; fn1: fn1, fn2: fn2 &#125;;&#125;)();优点&emsp;在模块外部无法修改我们没有暴露出来的变量、函数。CommonJS规范（NodeJS）&emsp;&emsp;由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。定义模块&emsp;根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。模块输出&emsp;模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象。加载模块&emsp;加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象12345678910111213141516//模块定义 myModel.jsvar name = 'Byron';function printName()&#123; console.log(name);&#125;function printFullName(firstName)&#123; console.log(firstName + name);&#125;module.exports = &#123; printName: printName, printFullName: printFullName&#125;//加载模块var nameModule = require('./myModel.js');nameModule.printName();&emsp;&emsp;不同的实现对require时的路径有不同要求，一般情况可以省略js拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块）尴尬的浏览器&emsp;&emsp;仔细看上面的代码，会发现require是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。&emsp;&emsp;浏览器端，加载JavaScript最佳、最容易的方式是在document中插入script 标签。但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载。解决思路：开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。 这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生了分歧：AMD CMDAMD&emsp;&emsp;Asynchromous Module Definition - 异步模块定义&emsp;&emsp;由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数RequireJS。&emsp;&emsp;AMD是RequireJS在推广过程中对模块定义的规范化产出，AMD是异步加载模块，推崇依赖前置。12345678910111213141516171819define('module1', ['jquery'], ($) =&gt; &#123;//do something...&#125;);代码中依赖被前置，当定义模块（module1）时，就会加载依赖（jquery）// 定义模块 myModule.jsdefine(['dependency'], function()&#123; var name = 'Byron'; function printName()&#123; console.log(name); &#125; return &#123; printName: printName &#125;;&#125;);// 加载模块require(['myModule'], function (my)&#123; my.printName();&#125;);解决的问题多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长。require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应。它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。CMD&emsp;&emsp;Common Module Definition - 公共模块定义）（国内发展出来的）&emsp;&emsp;CMD是SeaJS在推广过程中对模块定义的规范化产出，对于模块的依赖，CMD是延迟执行，推崇依赖就近。&emsp;&emsp;SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。推崇一个文件一个模块，所以经常就用文件名作为模块id。CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写。12345678define((require, exports, module) =&gt; &#123;module.exports = &#123;fun1: () =&gt; &#123;var $ = require('jquery');return $('#test');&#125; &#125;;&#125;);如上代码，只有当真正执行到fun1方法时，才回去执行jquery。同时CMD也是延自CommonJS Modules/2.0规范123456789// 定义模块 myModule.jsdefine(function(require, exports, module) &#123;var $ = require('jquery.js')$('div').addClass('active');&#125;);// 加载模块seajs.use(['myModule.js'], function(my)&#123;&#125;);AMD 和 CMDAMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块CMD推崇就近依赖，只有在用到某个模块的时候再去requireAMD用户体验好，因为没有延迟，依赖模块提前执行了。CMD性能好，因为只有用户需要的时候才执行。UMD&emsp;&emsp;Universal Module Definition - 通用模块定义&emsp;&emsp;UMD是AMD和CommonJS的一个糅合。&emsp;&emsp;AMD是浏览器优先，异步加载；CommonJS是服务器优先，同步加载。&emsp;&emsp;既然要通用，怎么办呢？那就先判断是否支持node.js的模块，存在就使用node.js；再判断是否支持AMD（define是否存在），存在则使用AMD的方式加载。这就是所谓的UMD。123456789101112131415((root, factory) =&gt; &#123;if (typeof define === 'function' &amp;&amp; define.amd) &#123;//AMDdefine(['jquery'], factory);&#125; else if (typeof exports === 'object') &#123;//CommonJSvar $ = requie('jquery');module.exports = factory($);&#125; else &#123;//都不是，浏览器全局定义root.testModule = factory(root.jQuery);&#125;&#125;)(this, ($) =&gt; &#123;//do something... 这里是真正的函数体&#125;);缺点&emsp;CommonJS 和 AMD 模块，都只能在运行时确定模块的依赖关系，以及输入和输出的变量。ES6(import)优点&emsp;ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.heavenbin.live/categories/JavaScript/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://blog.heavenbin.live/tags/模块化/"}]},{"title":"前端布局总结-盒子布局","slug":"前端布局总结-盒子布局","date":"2017-11-25T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/11/26/前端布局总结-盒子布局/","link":"","permalink":"http://blog.heavenbin.live/2017/11/26/前端布局总结-盒子布局/","excerpt":"","text":"盒子布局高度、宽度的选择与范围宽度使用rem的方式则使用 rem / % 都一样，哪个方便用哪个高度撑出高度(不设置高度)必须有高度 (外层：外层可以多层，且全部用% 内层：开始用rem之后)% （若有比例范围，则容易变形）外层 需要进行设置 —-一般全屏页面使用，方便比例内层 看同层盒子高度是否成比例 —-与rem没什么两样,方便比例rem （若有比例范围，则只能固定一个比例）外层 没有外层内层 最外层的固定高度 &lt; 适配手机的最小高度分辨率！！！！—-全屏 640x1136 微信+手机自带 640x1011 浏览器上下左右居中上下左右全包 方法一：flex ----未知宽度 display: flex; justify-content: center; align-items: center; 方法二：定位 width: 100px; height: 50px; position: absolute; top: 50%; left: 50%; margin-top: -25px; margin-left: -50px; ----固定宽度 transform: translate(-50%, -50%); ----未知宽度 左右居中 方法一：calc() margin-left: calc((100% - width)/2); ----固定宽度 方法二：margin margin-left: auto; margin-right: auto; ----未知宽度 方法三：行内元素 display: inline-block;text-align: center; ----行内居中 方法四：flex ----未知宽度 方法五：定位 width: 100px; height: 50px; position: absolute; left: 50%; margin-left: -50px; ----固定宽度 transform: translateX(-50%); ----未知宽度 上下居中 方法一：calc() margin-top: calc((100% - height)/2); ----固定宽度 方法二：行内元素 display: inline-block; height: 200px; line-height: 200px; ----行内居中 方法三：？ vertical-align: middle; ----？ 方法四：flex ----未知宽度 方法五：定位 width: 100px; height: 50px; position: absolute; top: 50%; margin-top: -25px; ----固定宽度 transform: translateY(-50%); ----未知宽度 布局方式及选择盒子内外边距 (单个盒子)稳定度： 宽高&gt;padding&gt;margin各种居中 (单个盒子)浮动流布局 (单个盒子)float &emsp; left right both定位流布局 (单个盒子 盒子外)position普通流布局 (多个盒子)从左到右，上到下，底边对齐，空白折叠，% + remdisplay &emsp; inline block inline-blockFlex布局 (多个盒子)display: flex; 九点筛子 + 项目之间的间隔比项目与边框的间隔大一倍space-around 实际功能： 1.普通流 ==== display 2.浮动 ==== float 3.固定比例 ==== 纵向% 横向 %+left 4.自适应 ==== % + rem + calc() 5.space-around ==== 感觉没啥用 盒子位置横向 首(间隔？)尾(间隔？)中(间隔？)两端(间隔？)四周(盒子间隔是边界间隔2倍)纵向 首 尾 中 文字基线 默认全高Grid布局 (多个盒子)Flex 与 GridGrid 定义两个维度， 更适合大模块的排布布局。Flex 定义一个维度， 更适合内部内容布局。在做一些布局时，可以同时使用 Grid 和 Flex。如 做类似瀑布流的卡片。卡片的布局用 Grid，卡片内部的布局 Flex。","categories":[{"name":"布局","slug":"布局","permalink":"http://blog.heavenbin.live/categories/布局/"}],"tags":[{"name":"盒子","slug":"盒子","permalink":"http://blog.heavenbin.live/tags/盒子/"}]},{"title":"前端布局总结-页面布局","slug":"前端布局总结-页面布局","date":"2017-11-06T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/11/07/前端布局总结-页面布局/","link":"","permalink":"http://blog.heavenbin.live/2017/11/07/前端布局总结-页面布局/","excerpt":"","text":"页面布局适配设备的屏幕比例范围三星安卓 1.777777778 (640x360) ----全屏 1.575 (567x360) ----微信+手机自带 1.530555556 1.43888889 原生 (511x360) UC (518x360) ----手机浏览器 iphone6 1.778666666667 (667x375) 1.608 (603x375) 1.490666667 (559x375) iphone5 1.775 (568X320) 1.575 (504x320) 1.4375 (460x320) 全屏页面布局原理 height:100%方式一html,body,div,…{height: 100%;}方式二固定高宽为clientHeight clientWidth123var id = document.getElementById('id');id.style.width = document.documentElement.clientWidth +'px';id.style.height = document.documentElement.clientHeight + 'px';方式三给父容器设置位置信息，让其得到高度信息。1234567div&#123; position:absolute; top:0px; left:0px; right:0px; bottom:0px; &#125;","categories":[{"name":"布局","slug":"布局","permalink":"http://blog.heavenbin.live/categories/布局/"}],"tags":[{"name":"页面","slug":"页面","permalink":"http://blog.heavenbin.live/tags/页面/"}]},{"title":"前端布局总结-终端布局","slug":"前端布局总结-终端布局","date":"2017-10-22T16:00:00.000Z","updated":"2018-09-30T08:34:07.000Z","comments":true,"path":"2017/10/23/前端布局总结-终端布局/","link":"","permalink":"http://blog.heavenbin.live/2017/10/23/前端布局总结-终端布局/","excerpt":"","text":"终端布局定宽布局(PC端)高宽固定流式布局(移动端)width:100% 宽响应，高固定，会变形123456div/body&#123; ----需要设置最大最小宽度限制，以免变形严重 min-width: 300px; max-width: 640px; margin: 0 auto; position: relative;&#125;rem布局(移动端)高宽响应，比例不变，不会变形 (rem&gt;=12px)123456789101112131415console.log(document.getElementsByTagName(\"html\")[0] === document.documentElement); //ture//设置rem (html的font-size) ;(function (win,doc)&#123;var recalc = function ()&#123;var docEL = doc.documentElement;if (!docEL.clientWidth) return;docEL.style.fontSize = docEL.clientWidth / 7.5 + 'px';&#125;if (!doc.addEventListener) return;//窗口改变事件(包括横竖屏切换orientationchange)win.addEventListener('resize', recalc, false);//DOM树构建完成事件doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(window,document)响应式布局(移动端+PC端)根据屏幕宽度 写多套样式 bootstrap 媒体查询","categories":[{"name":"布局","slug":"布局","permalink":"http://blog.heavenbin.live/categories/布局/"}],"tags":[{"name":"终端","slug":"终端","permalink":"http://blog.heavenbin.live/tags/终端/"}]},{"title":"Markdown速学教程","slug":"Markdown速学教程","date":"2017-09-16T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/09/17/Markdown速学教程/","link":"","permalink":"http://blog.heavenbin.live/2017/09/17/Markdown速学教程/","excerpt":"","text":"前言：这是一个速学Markdown教程，供给大家互相学习，有什么疑问可以issues我。源码地址：https://github.com/HeavenBin/MarkdownCourse顶部分级标题(‘#’)#+空格+一级标题一级标题##+空格+二级标题二级标题###+空格+三级标题三级标题####+空格+四级标题四级标题#####+空格+五级标题五级标题######+空格+六级标题六级标题空格(‘ ‘)1空格 = N空格/1换行 建议：1空格N空格 =1234&lt;pre&gt;标签&amp;ensp; 半方大的空白&amp;emsp; 全方大的空白&amp;nbsp; 不断行的空白格换行(‘ ‘+’回车’)1换行 = 2空格+1换行 建议：2空格+1换行2换行 = 2换行 建议：2换行N换行 =强调(*_~)*斜体 或者 _斜体_ 斜体*，_斜体_**粗体 或者 __粗体__ 粗体**，粗体***加粗斜体 加粗斜体***~~删除线~~删除线区块引用(&gt;)一一一一一一一一一一二二二二二二二二二二三三三三三三三三三三四四四四四四四四四四五五五五五五五五五五六六六六六六六六六六七七七七七七七七七七八八八八八八八八八八九九九九九九九九九九十十十十十十十十十十代码区块(tab)12345void main()&#123; printf(\"Hello, Markdown.\");&#125;#include &lt;stdio.h&gt;无序列表(- + *)第一项第二项第一项第二项第一项第二项有序列表(‘1. ‘)第一项第二项表格(‘|-‘)学号姓名分数小明男75小红女79小陆男92分割线*** — ___文字连接(‘[]()‘)欢迎来到baidu-停留没提示欢迎来到baidu-停留有提示图片链接(‘![]()‘)自动链接(‘&lt;&gt;’)http://example.com/锚点回到顶部内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。反转义作用(/)![图片名称](图片地址)>&gt;反转义作用***- 变成普通符号标记作用 ()ctrl+aFork或借鉴请注明出处 @ HeavenBin","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://blog.heavenbin.live/categories/Markdown/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://blog.heavenbin.live/tags/教程/"}]},{"title":"CSS选择器-性能的探究及提升","slug":"CSS选择器-性能的探究及提升","date":"2017-08-12T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/08/13/CSS选择器-性能的探究及提升/","link":"","permalink":"http://blog.heavenbin.live/2017/08/13/CSS选择器-性能的探究及提升/","excerpt":"","text":"前言：在工作中编写CSS样式表时随着选择器层数的增加总会看到选择器又丑又长的情况，利用工作之余研究从其命名再到如何提高其性能。本博客将以“通俗易懂”、“简洁”的方式来探究CSS选择器的性能，以及叙述总结如何提升CSS选择器的性能。一. CSS选择器性能是如何消耗的？工作原理：浏览器利用CSS选择器来匹配文档元素。工作流程：例如 #hd .nav &gt; a { padding-left: 15px }1.在文档所有元素中寻找所有的 a 标签。2.在1的结果中寻找其父元素的类名为“.nav”的元素。3.在2的结果中寻找其父辈元素的ID为“hd”的元素。4.在3的结果中增加样式。二. 分析怎么提升CSS选择器的性能？在工作流程中可以看出有两个方面可以提升性能：寻找的效率和寻找的次数效率：选择器的搜索个数，个数越少性能越好。次数：选择器的层数，层数越少性能越好。三. 提升CSS选择器性能的方式方式一（减少搜索个数）：选择效率高的选择器，参考如下建议多用类选择器少用标签选择器。 CSS选择器搜索个数从少到多的排序： id选择器（#myid） 类选择器（.myclassname） 标签选择器（div,h1,p） 相邻选择器（h1+p） 子选择器（ul > li） 后代选择器（li a） 通配符选择器（*） 属性选择器（a[rel=\"external\"]） 伪类选择器（a:hover, li:nth-child） 方式二（减少层数）：使用BEM（block_element-modifier）的命名方式。 BEM：块（block）、元素（element）、修饰符（modifier） 例如： .hd{} .hd_nav{} .hd_nav_a{} .hd_nav_a-link{} .hd_nav_a-visited{} 方式三（减少层数）：使用面向属性的命名方式。 面向属性：以“样式属性的功能”来给选择器命名。 例如： .l{ float: left } .tc{ text-align:center; } .auto{ margin-left:auto; margin-right:auto; }","categories":[{"name":"CSS","slug":"CSS","permalink":"http://blog.heavenbin.live/categories/CSS/"}],"tags":[{"name":"性能","slug":"性能","permalink":"http://blog.heavenbin.live/tags/性能/"}]},{"title":"《JavaScript高级程序设计》第十三章（4）","slug":"《JavaScript高级程序设计》第十三章（4）","date":"2017-06-16T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/06/17/《JavaScript高级程序设计》第十三章（4）/","link":"","permalink":"http://blog.heavenbin.live/2017/06/17/《JavaScript高级程序设计》第十三章（4）/","excerpt":"","text":"事件5 内存和性能添加到页面上的事件处理程序数量 关系到 整体运行性能1.程序占用内存，导致性能下降2.程序越多，整个页面的交互就绪时间就越长5.1 事件委托事件委托：“事件处理程序过多”的解决方案 (利用事件冒泡)例如：1&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;传统做法：为三个li元素分别添加事件事件委托：为更高的层次ul添加一个事件即可，在通过target对象来甄别触发的目标元素事件委托的优点：Document对象可以很快访问，且可以在页面生命周期的任何时点上个为它添加事件处理程序。减少就绪时间减少内存占用最适合的事件：click、mousedown、mouseup、keydown、keyup、keypress5.2 移除事件处理程序目的是 移除那些不需要的事件处理程序有两种情况需要注意：从文档中移除带有事件处理程序的元素时 解决方案：手工移除btn.onclick = null;卸载页面的时候 解决方案：onunload事件移除所有事件处理程序6 模拟事件DOM2级规范规定了模拟特定事件的方式，该冒泡还会冒泡，也会触发事件处理程序。6.1 DOM中的事件模拟步骤一：创建event对象Document对象上使用createEvent(事件类型的字符串) 创建event对象事件类型的字符串：UIEvents UI事件(鼠标和键盘事件都继承自UI事件) DOM3 UIEventMouseEvents 鼠标事件 DOM3 MouseEventMutationEvents DOM变动事件 DOM3 MutationEventHTMLEvents HTML事件 DOM3 被分散到其它类别中步骤二：初始化event对象每种类型的event对象都有一个特殊的方法，传入适当的数据来初始化。步骤三：触发事件元素的dispatchEvent(event对象) 触发事件1.模拟鼠标事件var btn = document.getElementById(“myBtn”);var event = document.createEvent(“MouseEvents”);event.initMouseEvent(15个参数);btn.dispatchEvent(event);15个参数：type(字符串) 事件类型，例如：“click”bubbles(布尔值) 是否冒泡cancelable(布尔值) 是否可以取消view(AbstractView) 与事件关联的视图detail(整数) 与事件有关的详细信息screenXscreenYclientXclientYctrlKeyaltKeyshiftKeymetaKeybutton(整数) 按下哪一个鼠标键，默认0relatedTarget 与事件相关的对象2.模拟键盘事件DOM3级var event = document.createEvent(“KeyboardEvent”);event.initKeyboardEvent(参数);**.dispatchEvent(event);Firefox中var event = document.createEvent(“KeyEvents”);event.initKeyEvent(参数);**.dispatchEvent(event);具体参数P407-408 通用事件P4093.模拟其他事件模拟变动事件模拟HTML事件4.自定义DOM事件目的：让开发人员创建自己的事件支持的浏览器：IE9+ Firefox6+6.2 IE中的事件模拟思路相似，但是每个步骤都采用了不一样的方式。var btn = doucument.getElementById(“myBtn”);创建事件对象：var event = document.createEventObject(); —-创建通用event对象初始化事件对象：event. = ~~~~;event. = ~~;event.** = ~~;…触发事件：btn.fireEvent(“onclick”,event); —-自动为event添加srcElement属性和type属性","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第十三章（3）","slug":"《JavaScript高级程序设计》第十三章（3）","date":"2017-06-11T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/06/12/《JavaScript高级程序设计》第十三章（3）/","link":"","permalink":"http://blog.heavenbin.live/2017/06/12/《JavaScript高级程序设计》第十三章（3）/","excerpt":"","text":"事件4 事件类型4.4 键盘与文本事件三个键盘事件：keydown 用户按下键盘上的任意键 按住不放重复触发keypress 用户按下键盘上的字符键 按住不放重复触发keyup 用户释放键盘上的键字符键 keydown —&gt; keypress —&gt; keyup非字符键 keydown —&gt; keyup键盘事件对象中也有shiftKey、ctrlKey、altKey、metaKey属性一个文本事件：textInput 在文本插入文本框之前 (对keypress的补充)1.键码keydown和keyup事件对象都有一个keyCode属性(值与键盘上一个特定的键对应)数字字母字符键 键码 与 ASCII码中对应小写字母或数字的编码 相同 (7 -&gt; 55, A -&gt; 65)非字符键 键码P380也会存在一些特殊情况。2.字符编码keypress在按下能够插入或删除字符的键时都会触发，支持一个charCode属性(值与代表字符的ASCII编码相同)此时keyCode值可能是0，也可能是键码跨浏览器的方式取得字符编码 P3813.DOM3级变化DOM3级不再包含charCode属性，新添加属性和方法：key 字符串 (字符键“k” 非字符键“Shift”)char 字符串 (字符键“k” 非字符键 null) IE不支持keyIdentifier 字符串 (字符键“U+0000” 非字符键“Shift”) Safari5 Chrome支持location 0默认键盘 1左侧位置 2右侧位置 3数字小键盘 4移动设备键盘 5手柄getModifierState(修改键字符串) 检测修改键是否活动中 仅IE9支持在跨浏览器开发中不推荐使用这些属性方法。4.textInput事件textInput事件 用户在可编辑区域中输入字符时触发与keypress区别：keypress 任何可以获得焦点的元素就行 textInput 只有可编辑区域才算keypress (退格键也算) textInput 只有输入实际字符才算特有属性：data 用户输入的字符(“S” “k”)inputMethod 文本输入到文本框的方式(仅IE支持)0不确定 1键盘 2粘贴 3拖放 4IME 5表单选择 6手写输入 7语音输入 8组合输入 9脚本5.设备中的键盘事件任天堂Wii会触发键盘事件，不是全部iOS版Safari和Android版WebKit 都会触发键盘事件4.5 复合事件复合事件：用于处理IME的输入序列。IME：输入法编辑器，可以输入物理键盘上找不到的字符，通常需要同时按住多个键，最终只输入一个字符。compositionstart IME的文本复合系统打开时(表示要开始输入了) data正在编辑的文本compositionupdate 向输入字段中插入新字符 data正在插入的新字符compositionend IME的文本复合系统关闭时(表示返回正常键盘输入状态) data会话中插入的所有字符这些事件对象的特有data属性IE9+是2011年唯一支持复合事件的浏览器，由于缺少支持，所以用处不大。4.6 变动事件变动事件：能在DOM中的某一部分发生变化时给出提示。(为XML/HTML DOM设计的)下面是DOM2级定义的变动事件DOMSubtreeModified DOM结构发生任何变化时触发(任何事件触发都会触发)DOMNodeInserted 节点作为子节点插入另一个节点DOMNodeRemoved 节点从其父节点中被移除DOMNodeInsertedIntoDocument 节点 直接或间接 插入文档之后 (DOMNodeInserted之后触发)DOMNodeRemovedFromDocument 节点 直接或间接 移出文档之前 (DOMNodeRemoved之后触发)DOMAttrModified 节点特性被修改之后DOMCharacterDataModified 文本节点的值发生变化时DOM3级作废了很多变动事件，下面只介绍还支持的。1.删除节点用removeChild()或者replaceChild()从DOM中删除ul节点时1234567&lt;body&gt;&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;ul 触发DOMNodeRemoved事件(event.target == ul,event.relatedNode == body) 冒泡ul及其所有子节点 触发DOMNodeRemovedFromDocument事件(event.target == 被触发的元素) 不会冒泡body 触发DOMSubtreeModified事件2.插入节点用appendChild()、replaceChild()或者insertBefore()向DOM中插入li节点时1234567&lt;body&gt;&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;li 触发DOMNodeInserted 事件(event.target == 被插入的元素,event.relateNode == ul) 冒泡li 触发DOMNodeInsertedIntoDocument事件(event.target == 被插入的元素) 不会冒泡ul 触发DOMSubtreeModified事件4.7 HTML5事件浏览器出于不同的目的，实现了一些自定义的事件。这里只讨论支持比较完善的事件。1.contextmenu事件contextmenu用以表示何时应该显示上下文菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单。P3892.beforeunload事件beforeunload为了让开发人员有可能在页面卸载前组织这一操作，通常就是弹出对话框，将控制权交给用户。P3903.DOMContentLoaded事件load 一切都加载完毕DOMContentLoaded 形成完整DOM树之后触发，不理会图像、JS文件、CSS文件DOMContentLoaded 早于load触发，这样用户可以更早地交互。如果不支持这个事件，建议setTimeout(function(){ ~ },0);必须作为页面中的第一个超时调用。4.readystatechange事件IE为DOM文档的某些部分提供readystatechange事件，目的是提供与文档或元素的加载状态有关的信息。同时也为DOM对象提供readyState属性：uninitialized 未初始化loading 正在加载loaded 加载完毕 (加载数据完成)interactive 交互complete 完成 (加载完毕)每个DOM对象未必拥有全部状态，通常readystatechange事件触发会少于4次对比DOMContentLoaded事件 (还不如用DOMContentLoaded)document的interactive状态，与DOMContentLoaded事件触发的时刻基本相同。对比load事件 (还不如用DOMContentLoaded)当加载东西多的时候，document的interactive状态 早于 load事件当加载东西少的时候，不一定支持readystatechange事件的浏览器有IE、Firfox4+、Operascript(在IE和Opera中)和link(仅IE)元素也会触发readystatechange事件 P3925.pageshow和pagehide事件Firefox和Opera有一个特性，“往返缓存”(bfcache)，能够加快“后退”/“前进”的转换速度。(转换不触发load事件)为了更形象地说明bfcache的行为，Firefox提供了pageshow事件、pagehide事件。都添加到window对象上pageshow事件 重新加载页面(load之后触发) bfcache页面(页面完全恢复的那一刻触发)它的persisted属性 页面是否被保存在bfcachepagehide事件 浏览器卸载页面(unload之前触发)它的persisted属性 卸载之后页面是否被保存在bfcache支持这两个事件的浏览器有Firefox、Safari5+、Chrome、Opera6.hashchange事件hashchange事件 当URL的参数列表发生变化时触发(必须添加到window对象上)它的属性：oldURL (变化前的URL) newURL (变化后的URL)支持hashchange事件的浏览器：IE8+、Firefox3.6+、Safari5+、Chrome、Opera10.6+支持它的两个属性的浏览器：Firefox6+、Chrome、Opera，所以推荐用location来确定当前的参数列表4.8 设备事件设备事件：让开发人员确定用户在怎样使用设备。1.orientationchange事件苹果公司为移动Safari添加(所有的iOS设备都支持，添加到window对象上)：orientationchange事件 用户改变设备的查看模式时触发window.orientation属性 0肖像模式 90左旋转的横向模式 -90右旋转的横向模式2.MozOrientation事件 (实验性API)Firefox3.6引入MozOrientation事件，当设备的加速计检测到设备方向改变时触发。(添加到window对象上)event对象包含三个属性：x,y,z 当设备处于竖直状态(0,0,1)只有带加速计的设备才支持MozOrientation事件。3.deviceorientation事件deviceorientation事件，当设备的加速计检测到设备方向改变时触发。(添加到window对象上)对比MozOrientation，这个事件更多的意图是告诉开发人员设备在空间中朝向哪儿。event对象包含五个属性：alpha 在围绕Z轴旋转时，y轴的度数差(0到360)beta 在围绕x轴旋转时，z轴的度数差(-180到180)gamma 在围绕y轴旋转时，z轴的度数差(-90到90)absolute 是否返回一个绝对值compassCalibrated 指南针是否校准过支持的浏览器有：iOS4.2+的Safari、Chrome和Android版WebKit。4.devicemotion事件devicemotion事件，告诉开发人员设备什么时候移动，而不仅仅是设备方向如何改变。(添加到window对象上)event对象的属性：acceleration 包含x,y,z属性的对象，不考虑重力的情况下，告诉你每个方向的加速度accelerationIncludingGravity …考虑Z轴重力的情况下，….interval 以毫秒表示的时间值rotationRate 一个包含alpha、beta、gamma属性的对象支持的浏览器有：iOS4.2+的Safari、Chrome和Android版WebKit。4.9 触摸与手势事件W3C开始制定Touch Events规范。下面的事件只针对触摸设备。1.触摸事件touchstart 当手指触摸屏幕时触发 (即使已经有手指在屏幕上)touchmove 当手指在屏幕上滑动时连续触发 (调用preventDefault()可以阻止滚动)touchend 当手指从屏幕上移开时触发touchcancel 当系统停止跟踪触摸时触发这几个事件都会冒泡，也都可以取消。event对象的属性：提供了鼠标事件的常见属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、 altKey、shiftKey、ctrlKey、metaKey。三个用于跟踪触摸的属性：touches 当前跟踪的触摸操作的Touch对象的数组targetTouchs 特定于事件目标的Touch对象的数组changeTouches 自上次触摸以来发生了什么改变的Touch对象的数组每个Touch对象包含的属性：clientX 触摸目标在视口中的x坐标clientY 触摸目标在视口中的y坐标pageX 触摸目标在页面中的x坐标pageY 触摸目标在页面中的y坐标screenX 触摸目标在屏幕中的x坐标screenY 触摸目标在屏幕中的y坐标target 触摸的DOM节点目标identifier 标识触摸的唯一ID在触摸屏幕上的元素时，这些事件(包括鼠标事件)发生的顺序如下：touchstartmouseovermousemove (一次)mousedownmouseupclicktouchend支持触摸事件的浏览器包括：iOS版的Safari、Android版WebKit、baba版Dolfin、OS6+中的BlackBerryWebKit、……2.手势事件当两个手指触摸屏幕时就会产生手势gesturestart 一个手指已经按在屏幕上，另一个手指又触摸屏幕时触发gesturechange 触摸屏幕的任何一个手指位置变化时触发gestureend 任何一个手指移开时触发这几个事件都会冒泡，所以可以放在文档上处理所有手势事件。event对象的属性：提供了鼠标事件的常见属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、 altKey、shiftKey、ctrlKey、metaKey。两个额外的属性：rotation 手指变化引起的旋转角度(起始0，逆时针负值，顺时针正值)scale 两个手指间的距离变化情况(起始1)","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第十三章（2）","slug":"《JavaScript高级程序设计》第十三章（2）","date":"2017-06-01T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/06/02/《JavaScript高级程序设计》第十三章（2）/","link":"","permalink":"http://blog.heavenbin.live/2017/06/02/《JavaScript高级程序设计》第十三章（2）/","excerpt":"","text":"事件3 事件对象event对象：包含着所有与事件有关的信息。所有浏览器都支持event对象，但支持方式不同。3.1 DOM中的事件对象兼容DOM的浏览器会将一个event对象传入到事件处理程序中。1&lt;input type=“button” value=“Click Me” onclick=“alert(event.type)”/&gt;btn.onclick = function(event){};btn.addEventListener(“click”, function(event){}, false)它的属性和方法(全部只读)：bubbles 是否冒泡 (Boolean)cancelable 是否可以取消事件的默认行为 (Boolean)currentTarget 其事件处理程序当前正在处理事件的那个元素 (Element)defaultPrevented 是否已经调用了preventDefault() (Boolean)detail 与事件相关的细节信息 (Integer)eventPhase 1 捕获阶段 2 处于目标 3 冒泡阶段 (Integer)preventDefault() 取消事件的默认行为stopImmediatePropagation() 取消进一步捕获或冒泡，且阻止任何事件程序调用stopPropagation() 取消进一步捕获或冒泡，bubbles才可调用这方法target 事件的目标 (Element)trusted true浏览器生成 false开发人员生成 (Boolean)type 被触发的事件的类型 (String)view 与事件关联的抽象视图，等同于它的window对象1.使用type可以通过一个函数处理多个事件2.preventDefault()可以阻止链接导航这一默认行为3.stopPropagation()可以取消进一步捕获或冒泡4.eventPhase 可以用来确定事件当前正位于事件流的哪个阶段3.2 IE中的事件对象访问IE中的event对象有几种不同的方式：DOM0级： window.eventattachEvent: event参数/window.eventHTML： event变量它的属性和方法：cancelBubble 默认false，true表示取消事件冒泡 (Boolean 读/写)returnValue 默认true，false表示取消事件的默认行为(Boolean 读/写)srcElement 事件的目标 (Element 只读)type 被触发的事件类型 (String 只读)1.this未必始终等于事件目标，用srcElement比较保险2.returnValue 相当于 preventDefault()3.cancelBubble 相当于 stopPropagation() 但是不支持事件捕获3.3 跨浏览器的事件对象根据DOM、IE中的事件对象，自己写一个EventUtil工具对象来实现跨浏览器4 事件类型“DOM3级事件”：UI事件 用户与页面上的元素交互焦点事件 元素获得或者失去焦点鼠标事件 用户通过鼠标在页面上执行操作滚轮事件 使用鼠标滚轮文本事件 在文档中输入文本时键盘事件 用户通过键盘在页面上执行操作时合成事件 为IME(输入法)输入字符时触发变动事件 底层DOM结构发生变化时变动名称事件 已经被废弃，不做介绍除此之外，还有HTML5事件，浏览器的专有事件。DOM3级事件模块 在 DOM2级事件模块 的基础上重新定义了这些事件，也添加了一些事件。4.1 UI事件DOMActivate 元素已经被用户操作激活(DOM3废弃，不建议使用)load 页面/框架/图片/嵌入内容 完全加载 window/框架集//上触发unload 页面/框架/图片/嵌入内容 完全卸载 window/框架集//上触发abort 在用户停止下载过程时，嵌入内容未加载完，上触发error 页面/框架/图片/嵌入内容 出现错误 window/框架集//上触发select 当用户选择文本框(input)或(texterea)中的一或多个字符时触发resize 窗口/框架 大小变化 window/框架 上触发scroll 当用户滚动带滚动条的元素中的内容时，在该元素上面触发。除DOMActivete之外，其它事件都归为HTML事件1.load事件两种方式定义onload事件处理程序：JavaScript(推荐) / 添加元素特性比如：window()、img、script2.unload事件两种方式定义onunload事件处理程序：JavaScript(推荐) / 添加元素特性最多的情况：清除引用，以避免内存泄漏注意：编写代码注意有些对象已经不存在了3.resize事件两种方式定义onresize事件处理程序：JavaScript(推荐) / 添加元素特性关于何时会触发resize事件，不同浏览器有不同的机制。注意：不要写入大量的计算代码，影响性能4.scroll事件虽然scroll事件是在window对象上发生的，但它实际表示的则是页面中相应元素的变化。注意：不要写入大量的计算代码，影响性能4.2 焦点事件focus 元素获得焦点 (早期 不会冒泡)blur 元素失去焦点 (早期 不会冒泡)DOMFocusIn 元素获得焦点 (Opera 会冒泡)DOMFocusOut 元素失去焦点 (Opera 会冒泡)focusin 元素获得焦点 (IE纳入DOM3 会冒泡)focusout 元素失去焦点 (IE纳入DOM3 会冒泡)利用这些事件与document.hasFocus()方法及document.activeElement属性配合，可以知道用户行踪。4.3 鼠标与滚轮事件click 用户单击主鼠标按钮/按下回车键dblclick 用户双击鼠标按钮mousedown 用户按下了任意鼠标按钮mouseup 用户释放鼠标按钮mouseenter 鼠标光标刚进入 元素范围(不冒泡)mouseleave 鼠标光标刚离开元素范围(不冒泡)mousemove 鼠标光标在元素范围内移动mouseout 鼠标光标刚进入 元素或其子元素 范围mouseover 鼠标光标刚离开 元素或其子元素 范围mousewheel 滚轮事件4个事件的触发顺序：mousedown mouseup clickmousedown mouseup clickdblclickclick 和 dblclick都会依赖其他先行事件的触发1.客户区坐标位置clientX 事件发生时鼠标指针在视口中的水平坐标clientY 事件发生时鼠标指针在视口中的垂直坐标因为只是相对于视口，不包括被挡住的滚轮距离，所以不能代表鼠标在页面上的位置。2.页面坐标位置pageX 事件发生时鼠标指针在页面中的水平坐标pageY 事件发生时鼠标指针在页面中的垂直坐标在页面没有滚动的情况下，pageX和pageY的值与clientX和clientY的值相等。3.屏幕坐标位置screenX 事件发生时鼠标指针在整个屏幕中的水平坐标screenY 事件发生时鼠标指针在整个屏幕中的垂直坐标4.修改键修改键：Shift 对应属性 shiftKeyCtrl 对应属性 ctrlKeyAlt 对应属性 altKeyMeta 对应属性 metaKey (windows键盘的window键，Mac键盘的Cmd键)这些属性值为true，说明触发事件时同时按下这些键5.相关元素仅对于mouseover、mouseout事件提供的relatedTarget属性，其它事件为null。mouseover事件 刚进入元素(被离开的元素为相关元素) relatedTarget fromElement(IE8)mouseout事件 刚离开元素(被进入的元素为相关元素) relatedTarget toElement(IE8)6.鼠标按钮button属性 0/1/2 按下或释放 主鼠标按钮/中间的鼠标按钮/次鼠标按钮这个属性对于mousedown、mouseup事件来说挺有用的。IE8及之前版本也有button属性，有很大差异。7.更多的事件信息detail属性 在给定位置上发生了多少次单击 (从1开始计数，换位置则为0)IE提供了下列属性：altLeft 是否按下Alt键ctrlLeft 是否按下Ctrl键shiftLeft 是否按下Shift键offsetX 光标相对于目标元素边界的x坐标offsetY 光标相对于目标元素边界的y坐标这些属性用处并不大，一是仅IE支持，二是可以通过其它方式获得。8.鼠标滚轮事件mousewheel事件 用户通过鼠标滚轮与页面交互，在垂直方向上滚动页面时触发提供特殊的wheelDelta属性 120的倍数/-120的倍数 表示 向前滚动/向后滚动Opera9.5之前的版本，wheelDelta值的正负号是颠倒的。Firefox支持一个名为DOMMouseScroll的类似事件，特殊属性则是detail跨浏览器方案：P3779.触摸设备iOS和Android设备的实现非常特别，因为这些设备没有鼠标。在面向iPhone和iPod中的Safari开发时，要记住以下坑：不支持dblclick事件。轻击可单击元素会触发mousemove事件。mousemove事件也会触发mouseover和mouseout事件两个手指放在屏幕上且页面随手指移动而滚动时会触发mousewheel和scroll事件10.无障碍性问题确保残疾人特别是那些使用屏幕阅读器的人都能访问，使用鼠标事件时应当注意几个访问性问题：使用click事件执行代码。不要使用onmouseover向用户显示新的选项。不要使用dblclick执行重要的操作。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第十三章（1）","slug":"《JavaScript高级程序设计》第十三章（1）","date":"2017-05-27T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/05/28/《JavaScript高级程序设计》第十三章（1）/","link":"","permalink":"http://blog.heavenbin.live/2017/05/28/《JavaScript高级程序设计》第十三章（1）/","excerpt":"","text":"事件JavaScript与HTML之间的交互是通过事件实现的。使用侦听器(或处理程序)来预订事件(观察员模式)浏览器全都实现了“DOM2级事件”，IE8是最后一个仍然使用其专有事件系统的主要浏览器1 事件流事件流：从页面中接收事件的顺序 IE的事件流(事件冒泡流) Netscape的事件流(事件捕获流)1.1 事件冒泡事件冒泡：最具体的节点 —-&gt; 不太具体的节点—&gt;—&gt;—&gt; document —&gt; window1.2 事件捕获事件捕获：不太具体的节点 —-&gt; 最具体的节点window —&gt; document —&gt;—&gt;—&gt;很少用事件捕获(老版本的浏览器不支持)，基本都用事件冒泡1.3 DOM事件流DOM事件流包括三个阶段：事件捕获阶段 —&gt; 处于目标阶段 —&gt; 事件冒泡阶段window —&gt; document —&gt;—&gt;—&gt;—&gt;—&gt;—&gt; document —&gt; window绿色部分(事件捕获阶段) —- 包括 处于目标阶段(浏览器实现)红色部分(处于目标阶段)蓝色部分(事件冒泡阶段) —- 包括 处于目标阶段(DOM规定)2 事件处理程序事件 用户或浏览器自身执行的某种动作 click事件处理程序 事件处理程序(事件侦听器) onclick为事件指定处理程序的方式有好几种2.1 HTML事件处理程序某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定。 为了避免使用HTML实体，使用单引号 独到之处：函数里面有局部变量event 代表 事件对象，this代表 事件的目标元素HTML事件处理程序的缺点：1.页面解析程序之前，就触发了事件，就会引发错误。解决方案：try{showMessage();} catch(ex){} 捕获错误，不会显示出来2.在不同的浏览器中会导致不同的作用域链3.改动的时候麻烦：需要改动HTML和JS代码两个地方。2.2 DOM0级事件处理程序每个元素 都有自己的 事件处理程序属性var btn = document.getElementById(“myBtn”);btn.onclick = function() {}; —- this 代表 当前元素，相当于 元素的方法 (在冒泡阶段被处理)btn.onclick = null; —- 删除事件处理程序2.3 DOM2级事件处理程序所有DOM节点都包含这两个方法(能够一个事件添加多个函数)：addEventListener(事件名,处理函数,布尔值) 为事件指定处理程序 (只能用removeEventListener移除)removeEventListener(事件名,处理函数,布尔值) 为事件移除处理程序 (无法移除匿名函数)布尔值(true捕获阶段调用 false冒泡阶段调用)var handler = function(){}btn.addEventListener(“click”,handler,false)btn.removeEventListener(“click”,handler,false)推荐使用冒泡阶段(false)，最好只在需要在事件到达目标之前截获它的时候才用捕获阶段(true)2.4 IE事件处理程序IE实现了类似的两个方法(能够一个事件添加多个函数，但是相反的顺序执行函数)：attachEvent(处理程序名,处理函数) 为事件指定处理程序 (只能用detachEvent移除) 都是冒泡阶段 this 代表 windowdetachEvent(处理程序名,处理函数) 为事件移除处理程序 (无法移除匿名函数)var handler = function(){}btn.attachEvent(“onclick”,handler)btn.detachEvent(“onclick”,handler)2.5 跨浏览器的事件处理程序结合DOM0级事件处理程序、DOM2级事件处理程序、IE事件处理程序，自己写addHandler()、removeHandler() P354","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第十二章（2）","slug":"《JavaScript高级程序设计》第十二章（2）","date":"2017-05-20T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/05/21/《JavaScript高级程序设计》第十二章（2）/","link":"","permalink":"http://blog.heavenbin.live/2017/05/21/《JavaScript高级程序设计》第十二章（2）/","excerpt":"","text":"DOM2和DOM33 遍历“DOM2级遍历和范围”模块定义了两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator、TreeWalker它们能够基于给定的起点对DOM结构执行深度优先(depth-first)的遍历操作。(遍历以给定节点为根，不可能向上超出DOM树的根节点 IE不支持DOM遍历)3.1 NodeIteratordocument.createNodeIterator() 创建NodeIterator类型的实例 返回Node的迭代器参数：root 想要作为搜索起点的树中的节点whatToShow 要访问哪些节点的数字代码 (位掩码，参数的值P328)filter NodeFilter对象或函数 (筛选是否访问)entityReferenceExpansion 布尔值，是否要扩展实体引用这个实例提供两个方法(这样就可以遍历了)：nextNode() 到下一个节点(没有的时候返回null)previousNode() 到上一个节点(没有的时候返回null)filter返回值：NodeFilter.FILTER_ACCEPT 可以加入迭代器NodeFilter.FILTER_SKIP 跳过这个节点3.2 TreeWalker相当于NodeIterator的一个更高级的版本。document.createTreeWalker() 创建TreeWalker类型的实例 返回Node的迭代器参数：与createNodeIterator一致比createNodeIterator多的属性和方法：parentNode() 到当前节点的父节点firstChild() 到当前节点的第一个子节点lastChild() 到当前节点的最后一个子节点nextSibling() 到当前节点的下一个同辈节点previousSibling() 到当前节点的上一个同辈节点currentNode 在上一次遍历中返回的节点filter返回值(多一个)：NodeFilter.FILTER_REJECT 跳过这个节点及其整个子树TreeWalker更加灵活，但是IE中没有对应的类型和方法。4 范围“DOM2级遍历和范围”模块定义了“范围”接口，可以用来选择文档的一个区域，而不考虑节点的界限。在常规的DOM操作不能更有效地修改文档时，使用范围往往可以达到目的。4.1 DOM中的范围DOM2级在Document类型中定义了createRange()方法，用来创建DOM范围。(与节点相似，与文档关联，不可用于其它文档那个)var range = document.createRange();每个范围(Range类型的实例) 属性和方法：startContainer 包含范围起点的节点(即选区中第一个节点的父节点)startOffset 范围在startContainer中起点的偏移量endContainer 包含范围终点的节点(即选区中最后一个节点的父节点)endOffset 范围在endContainer中终点的偏移量commonAncestorContainer startContainer、endContainer共同的祖先节点在文档树中位置最深的那个1.用DOM范围实现简单选择DOM范围的方法：selectNode(节点) 选择整个节点，包括其子节点 —-1selectNodeContents(节点) 只选择节点的子节点 —-2Hello world!红色为2 全部为1更精确的方法setStartBefore(节点) 将范围的起点设置在参数节点之前setStartAfter(节点) 将范围的起点设置在参数节点之后setEndBefore(节点) 将范围的终点设置在参数节点之前setEndAfter(节点) 将范围的终点设置在参数节点之后2.用DOM范围实现复杂选择DOM范围的方法：setStart(参照节点,偏移量值) 对应设置startContainer、startOffsetsetEnd(参照节点,偏移量值) 对应设置endContainer、endOffset它们更胜一筹的地方在于 能够选择节点的一部分3.操作DOM范围中的内容4.插入DOM范围中的内容5.折叠DOM范围6.比较DOM范围7.复制DOM范围8.清理DOM范围4.2 IE8及更早版本中的范围(略)","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第十二章（1）","slug":"《JavaScript高级程序设计》第十二章（1）","date":"2017-05-16T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/05/17/《JavaScript高级程序设计》第十二章（1）/","link":"","permalink":"http://blog.heavenbin.live/2017/05/17/《JavaScript高级程序设计》第十二章（1）/","excerpt":"","text":"DOM2和DOM3DOM1 定义的是HTML/XML文档的底层结构。DOM2和DOM3 在这个结构的基础上引入更多的交互能力。(分为许多模块，且模块之间具有某种关联)DOM2级核心(DOM Level 2 Core) 为节点添加了更多的方法和属性DOM2级视图(DOM Level 2 Views) 为文档定义了基于样式信息的不同视图DOM2级事件(DOM Level 2 Events) 说明了如何使用事件与DOM文档交互 —-13章DOM2级样式(DOM Level 2 Style) 定义了如何以编程方式来访问和改变CSS样式信息DOM2级遍历和范围(DOM Level 2 Traversal and Range) 遍历DOM文档和选择其特定部分的新接口DOM2级HTML(DOM Level 2 HTML) 在1级HTML基础上，添加了更多属性、方法、接口DOM3级 添加了 “XPath”模块 和 “加载与保存”(Load and Save)模块 —-18章1 DOM变化DOM2、DOM3目的是在于扩展DOM API，以满足操作XML的所有需求，同时提供更好的错误处理及特性检测能力。DOM2没有引入新类型，DOM3引入了新类型。DOM2级视图 和 DOM2级HTML 模块很小，将和 DOM2级核心 放在一起讨论1.1 针对XML命名空间的变化XML命名空间：可以将不同XML文档的元素混合在一起，共同构成格式良好的文档，而不同担心发生命名冲突了。1234567&lt;html xmlns=“http://www.w3.org/1999/xhtml”&gt; //命名空间...&lt;svg xmlns=“http://www.w3.org/2000/svg” version=“fill:red”&gt; //命名空间...&lt;/svg&gt;...&lt;/html&gt;元素属于哪个命名空间？ DOM2、DOM3提供了相关属性和方法。1.Node类型的变化DOM2提供属性，DOM3提供方法2.Document类型的变化DOM2提供方法3.Element类型的变化DOM2提供方法4.NamedNodeMap类型的变化提供了方法1.2 其它方面的变化讲的是“DOM2级核心”1.DocumentType类型的变化&lt;!DOCTYPE html PUBLIC “- //W3C//DTD XHTML 1.0 Strict//EN” 1“http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd” 2[&lt;!ELEMENT name (#PCDATA)&gt;] 3新增3个属性：document.doctype.publicId 文档类型声明中的第一个信息段 1document.doctype.systemId 文档类型声明中的第二个信息段 2document.doctype.internalSubset 文档类型声明的额外定义 3三个属性在HTML中很少用到，XML中常见一些2.Document类型的变化新增方法：importNode(要复制的节点, 是否复制子节点) 取得一个节点，将其导入到另一个文档(与cloneNode方法非常相似)为document.implementation对象新增：createDocumentType(文档类型名称,publicID,systemId) 创建DocumentType节点createDocument() 创建新文档三个参数：针对文档中元素的namespaceURI、文档元素的标签名、新文档的文档类型“DOM2级HTML”添加：createHTMLDocument(文档标题) 创建完整的HTML文档“DOM2级视图” 添加：defaultView属性 指向拥有给定文档的窗口或框架( IE parentWindow )3.Node类型的变化新增方法：isSupported(特性名,特性版本号) 确定当前节点是否具有这个能力( 与 hasFeature方法非常相似)未必准确，最好还是使用能力检测。 DOM3新增：isSameNode(一个节点) 传入节点和引用节点是否相同( 引用同一个对象 )isEqualNode(一个节点) 传入节点和引用节点是否相等( 相同的类型 )setUserData(要设置的键,实际的数据，处理函数) 将数据指定给一个节点getUserData(键) 获取键对应的数据处理函数会在节点被复制、删除、重名名或引入一个文档时调用(接收5个参数，不细写了)4.框架的变化HTMLFrameElement代表 框架 HTMLIFrameElement代表 内嵌框架DOM2给它们新增属性：contentDocument 指向表示框架内容的文档对象 (之前只能使用frames集合获得)也是Document类型的实例 IE8之前不支持，但是有contentWindow属性。兼容性写法：var iframe = document.getElementById(“myIframe”);var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;2 样式“DOM2级样式”模块围绕定义样式的3种方式提供了一套API。方式一：link标签 包含 外部样式表文件方式二：style标签 定义 嵌入式样式方式三：style特性 定义 针对特定元素的样式2.1 访问元素的样式HTML元素的 style特性 对应 JS的 style属性 ( CSSStyleDeclaration的实例 )CSS属性( 短划线 ) 对应 JS属性(驼峰大小写)特殊CSS属性：float ==== cssFloat( DOM2级样式 ) ==== styleFloat(IE)在JS中设置myDiv.style.backgroundColor = “red”;在元素中设置1.DOM样式属性和方法为style对象定义了一些属性和方法：cssText style特性中的CSS代码读取模式(返回CSS代码的内部表示) 写入模式(重写整个style特性的值)length CSS属性的数量item(index) 返回给定位置的CSS属性的名称getPropertyValue() 返回给定属性的字符串值getPropertyCSSValue() 返回包含给定属性值的CSSValue对象包含两个属性：cssText(属性的字符串值) cssValueType(0继承的值1基本的值2值列表3自定义的值)getPropertyPriority() 使用了!important,返回important,否则返回空字符串removeProperty() 删除给定属性setProperty(属性名,属性值,标志) 设置属性值，并加上优先权标志(important/空字符串)2.计算的样式计算的样式：style特性+内嵌样式+外部样式，只读的。为document.defaultView添加：getComputedStyle( 计算的元素, 伪元素字符串[:after/..] ) 返回CSSStyleDeclaration对象(类似style属性)返回的对象包括style特性 + 内嵌的样式 + 外部样式 IE不支持，但有currentStyle属性document.defaultView.getComputedStyle(myDiv,null); 对应 myDiv.currentStyle;2.2 操作样式表CSSStyleSheet类型 表示 样式表 (继承自 StyleSheet)StyleSheet继承而来的属性：….太多，略P317document.styleSheets 文档的所有样式表集合 (不同浏览器返回的样式表也不同)document.styleSheets.length 样式表的数量获取CSSStyleSheet类型：document.styleSheets[i] —-文档节点上获取var link = document.getElementsByTagName(“link”)[0];link.sheet(DOM规定) link.styleSheet(IE规定) —-元素节点上获取1.CSS规则div.box{ —-一条规则…}CSSRule类型 表示 样式表中的每一条规则 (它是略中的属性)CSSStyleRule类型 表示 样式信息 (继承自CSSRule)CSSStyleRule类型包含的属性：….太多，略P318获取规则，修改规则的操作(略)2.创建规则insertRule( 规则文本, 插入的索引 ) 在样式表中添加新规则addRule( 选择符文本, CSS样式信息, 插入位置[可选] ) 类似方法(IE8及更早)var sheet = document.styleSheets[0];sheet.insertRule(“body{ background-color: silver }”, 0);sheet.addRule(“body”, “background-color: silver”, 0);这种方式还是比较繁琐，不如第10章的动态加载样式表技术3.删除规则deleteRule( 删除的位置 ) 在样式表中删除规则removeRule( 删除的位置 ) 类似方法(IE)这种方式还是不好，不推荐2.3 元素大小DOM中没有规定如何确定页面中元素的大小，IE引入了一些属性。很多浏览器都支持这些属性。1.偏移量 (元素与外部元素)offsetHeight 元素的高度 + 上下边框高度 + 水平滚动条高度(像素)offsetWidth 元素的宽度 + 左右边框高度 + 垂直滚动条宽度(像素)offsetLeft 元素左外边框 至 外部元素左内边框 之间的距离(像素)offsetTop 元素上外边框 至 外部元素上内边框 之间的距离(像素)offsetParent 外部元素(包含元素)这些值都是只读的，访问需要重新计算，多次访问建议先保存在局部变量2.客户区大小 (元素内容与元素内边距) 不同浏览器值不一样clientWidth 元素内容区宽度 + 左右内边距宽度clientHeight 元素内容区高度 + 上下内边距高度这些值都是只读的，访问需要重新计算，多次访问建议先保存在局部变量3.滚动大小 (包含滚动内容的元素) 不同浏览器值不一样scrollHeight 在没有滚动条的情况下，元素内容的总高度scrollWidth 在没有滚动条的情况下，元素内容的总宽度scrollLeft 被隐藏在内容区域左侧的像素数。 (可以设置滚动位置)scrollTop 被隐藏在内容区域上方的像素数。 (可以设置滚动位置)clientHeight/Width = padding + height - 滚动条offsetHeight/Width = padding + height + border = clientHeight + 滚动条 + 边框scrollHeight/Width = padding + height (滚动大小：隐藏的内容也算)4.确定元素大小getBoundingClientRect() 返回矩形对象(四个属性：left、top、right、bottom)元素在页面中相对视口的位置 不同浏览器的实现稍有不同，IE8及更早版本：左上角坐标(2,2)，其它浏览器：左上角坐标(0,0)","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第十一章（2）","slug":"《JavaScript高级程序设计》第十一章（2）","date":"2017-05-09T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/05/10/《JavaScript高级程序设计》第十一章（2）/","link":"","permalink":"http://blog.heavenbin.live/2017/05/10/《JavaScript高级程序设计》第十一章（2）/","excerpt":"","text":"DOM扩展4 专有扩展在编写这书的时候，这些大量的DOM扩展还没有成为标准。只得到少数浏览器的支持。4.1 文档模式IE8 引入了“文档模式” (不同的模式使用不同级别的CSS，不同的JS API)四种文档模式：IE5 IE7 IE8 IE9强制浏览器以某种模式渲染页面：1&lt;meta http-equiv=“X-UA-Compatible” content=“IE=IEVersion”&gt;IEVersion的值：Edge 始终以最新的文档模式来渲染页面EmulateIE9/8/7 有文档类型声明 IE9/8/7 没有 IE59/8/7/5 强制IE9/8/7/5IE8提供了document.documentMode属性 (使用的文档模式)4.2 children属性IE9之前的版本与其它浏览器在处理文本节点中的空白符时有差异children属性是HTMLCollection的实例。(除了只返回元素子节点，其它跟childNodes没有什么区别)IE8及以前： children 还会包含注释节点(bug)IE9之后： children 只包含元素节点4.3 contains()方法某个节点 是不是 另一个节点的后代IE率先引入contains()a节点.contains(b节点) b节点是不是a节点的后代 (true/false)DOM Level 3 的compareDocumentPosition() 也能够确定节点间的关系。返回一个表示该关系的位掩码1 ==== 无关 2 ==== 居前 4 ==== 居后 8 ==== 包含 16 ==== 被包含4.4 插入文本IE的四个属性innerHTML outerHTML 被纳入标准innerText outerText 没有纳入 (操作元素中包含的所有文本内容)1.innerText属性读取值时： 将子文档树中的所有文本拼接起来写入值时： 删除所有子节点，添加一个子文本节点DOM Level 3 规定的textContent属性拥有类似的功能2.outerText属性读取值时： 与innerText一样写入值时： 删除所有子节点(包括调用节点)，添加一个文本节点 —-相当于 调用节点 替换成 文本节点4.5 滚动1 scrollIntoView()纳入规范之后，还有几个专有方法可以在不同的浏览器中使用。2 scrollIntoViewIfNeeded( alignCenter ) true(视口中部上下垂直)3 scrollByLines( lineCount ) 将元素的内容滚动指定的页面行度4 scrollByPages( pageCount ) 将元素的内容滚动指定的页面高度1、2 作用对象是元素的容器，3、4作用对象是元素自身1 唯一一个所有浏览器都支持的方法，最常用的方法","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第十一章（1）","slug":"《JavaScript高级程序设计》第十一章（1）","date":"2017-05-04T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/05/05/《JavaScript高级程序设计》第十一章（1）/","link":"","permalink":"http://blog.heavenbin.live/2017/05/05/《JavaScript高级程序设计》第十一章（1）/","excerpt":"","text":"DOM扩展主要三个扩展： 专有扩展(浏览器自定) + Selectors API(选择符API) + HTML51 选择符APISelectors API Level 1的核心：querySeletor()、querySeletorAll()Selectors API Level 2的核心：matchesSelector()1.1 querySeletor()方法querySelector(CSS选择符) 返回匹配的第一个元素( 空则返回null 仅查找该元素的后代元素 )var myDiv = document.querySelector(“#myDiv”);1.2 querySelectorAll()方法querySelectorAll(CSS选择符) 返回所有匹配的元素 ( NodeList实例，相当于快照，没有动态 )var strongs = document.querySelectorAll(“p strong”);1.3 matchesSelector()方法matchesSelector(CSS选择符) 调用元素与该选择符是否匹配(true/false) 2011年年中都还未支持2 元素遍历之前一些属性会返回文本节点和注释节点。Element Traversal API为DOM元素添加了以下5个属性：childElementCount 返回子元素(不包含文本节点和注释)的个数firstElementChild 指向第一个子元素；firstChild的元素版lastElementChild 指向最后一个子元素；lastChild的元素版previousElementSibling 指向前一个同辈元素；previousSibling的元素版nextElementSibling 指向后一个同辈元素；nextSibling的元素版这样遍历NodeList的时候就不用判断是否是元素节点3 HTML5HTML5围绕如何使用新增标记定义了大量的JS API本章只讲和DOM有关的那部分API。3.1 与类(class)相关的扩充class属性用的越来越多，用来 给元素添加样式/表示元素的语义1.getElementsByClassName()方法getElementsByClassName(一或多个类名字符串) 返回带有指定类的所有元素的NodeListdocument.getElementsByClassName(“username current”)document对象调用：返回匹配的所有元素 元素调用：返回匹配的后代元素2.classList属性之前className属性是字符串，当需要添加类名的时候，很麻烦(字符串==&gt;数组==&gt;添加)classList属性(新集合类型DOMTokenList的实例) 更方便地 添加、删除、替换类名。length 包含多少个类名add(value) 将字符串添加到列表中contains(value) 判断是否存在该字符串remove(value) 删除指定字符串toggle(value) 有则删除，无则添加3.2 焦点管理document.activeElement 始终会引用DOM中当前获得了焦点的元素。获得焦点的方式：页面加载、用户输入、调用focus()文档加载期间 null文档刚加载完成 document.bodydocument.hasFocus() 确定文档是否获得了焦点，可以知道用户是否在交互。3.3 HTMLDocument 的变化1.readyState属性loading 正在加载文档complete 已经加载完文档2.兼容模式 ( compatMode属性 )区分页面的渲染模式CSS1Compat 标准模式BackCompat 混杂模式3.head属性document.head 引用文档的元素3.4 字符集属性charset属性 实际使用的字符集( 默认 UTF-16 )defaultCharset属性 根据操作系统和浏览器设置判断字符集应该是什么应用：if(document.charset != document.defaultCharset){alert(“使用的是自定义字符集”);}3.5自定义数据属性HTML5规定可以为元素添加 非标准的属性 (要添加前缀data-)目的：提供与渲染无关的信息 提供语义信息场景：给元素添加一些不可见的数据以便进行其他处理访问：元素的dataset属性( DOMStringMap的一个实例 )var div = document.getElementById(“myDiv”);div.dataset.appId //12345(没有data-)3.6 插入标记(DOM操作)前面的DOM操作技术非常麻烦1.innerHTML属性不支持的元素：12&lt;col&gt; &lt;colgroup&gt; &lt;frameset&gt; &lt;head&gt; &lt;html&gt; &lt;style&gt; &lt;table&gt; &lt;tbody&gt; &lt;thead&gt; &lt;tfoot&gt; &lt;tr&gt;读模式：innerHTML返回与调用元素的所有子节点对应的HTML标记写模式：指定值 ==序列化转换==&gt; 新的DOM树 ====&gt; 替换原先的所有子节点不同的浏览器 序列化后 返回的结果也不同大多数浏览器通过innerHTML插入script元素并不会执行其中的脚本大多数浏览器都支持以直观的方式通过innerHTML插入style元素建议在通过innerHTML插入代码之前，尽可能先手工检查一下其中的文本内容。2.outerHTML属性读模式：outerHTML返回调用它的元素及其所有子节点对应的HTML标签写模式：指定HTML字符串 ==序列化转换==&gt; 新的DOM树 ====&gt; 替换调用元素不同的浏览器 序列化后 返回的结果也不同3.insertAdjacentHTML()方法insertAdjacentHTML() 插入标记参数一(插入位置)beforebegin 当前元素 之前 插入 紧邻的同辈元素afterbegin 当前元素 之下 插入 第一个子元素beforeend 当前元素 之下 插入 最后一个子元素afterend 当前元素 之后 插入 紧邻的同辈元素参数二(要插入的HTML文本 与innerHTML、outerHTML的值相同)4.内存与性能问题内存问题：某个元素 有事件处理程序 或者 引用了其它JS对象作为属性。删除这个元素的话， 和事件处理程序、JS对象的绑定关系并没有一并删除，导致内存积累。建议：先手工删除要被替换的元素的所有事件处理程序和JS对象属性性能问题：设置innerHTML/outerHTML时，会创建一个HTML解析器。ul.innerHTML += “” + value[i] + “”; //频繁设置会导致性能地下ul.innerHTML = itemsHTML; //一次设置节省性能尽量减少设置innerHTML/outerHTML3.7 scrollIntoView()方法scollIntoView() 方法用于滚动页面 (所有元素都可以调用)参数true/不传参 调用元素顶部 与 视口顶部 尽可能平齐参数false 调用元素底部 与 视口底部 尽可能平齐","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第十章（3）","slug":"《JavaScript高级程序设计》第十章（3）","date":"2017-04-28T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/04/29/《JavaScript高级程序设计》第十章（3）/","link":"","permalink":"http://blog.heavenbin.live/2017/04/29/《JavaScript高级程序设计》第十章（3）/","excerpt":"","text":"DOM(文档对象模型)2 DOM操作技术处理DOM充斥着陷阱和不兼容问题。DOM操作往往是JS程序中开销最大的部分，尽量减少DOM操作2.1 动态脚本动态脚本：在页面加载时不存在，但将来的某一时刻通过修改DOM动态添加的脚本。有两种方式：插入外部文件 JS拼凑script标签，需要时添加到body节点尾部直接插入JS代码 需要时添加 文本节点(脚本语句) 到script节点中2.2 动态样式动态样式：在页面加载完成后动态添加到页面中的样式。link 加入外部文件 JS拼凑link标签，需要时添加到head节点尾部style 加入内嵌样式 需要时添加 文本节点(样式代码) 到style节点中2.3 操作表格都是用DOM操作，懒得看2.4 使用NodeListNodeList NamedNodeMap HTMLCollection 动态的对他们进行某些操作的时候，会出现无限循环的状态12345var divs = document.getElementsByTagName(“div”); for(i=0;i&lt;divs.length;i++)&#123; //因为length是动态的，所以会无限循环 div = document.createElement(“div”); for(i=0,len=divs.length;i&lt;len;i++)//可以避免document.body.appendChild(div);&#125;尽量减少访问NodeList的次数","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第十章（2）","slug":"《JavaScript高级程序设计》第十章（2）","date":"2017-04-24T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/04/25/《JavaScript高级程序设计》第十章（2）/","link":"","permalink":"http://blog.heavenbin.live/2017/04/25/《JavaScript高级程序设计》第十章（2）/","excerpt":"","text":"DOM(文档对象模型)1 节点层次1.4 Text类型JS通过Text类型 表现 文本节点，包含的 纯文本内容。Text 节点特征：nodeType == 3nodeName == “#text”nodeValue == 文本值 == dataparentNode == Element没有子节点appendData(text) 节点末尾添加textdeleteData(offset,count) 从offset位置开始删除count个字符insertData(offset,text) 从offset位置插入textreplaceData(offset,count,text) 从offset位置开始替换为text，删除count个字符splitText(offset) 从offset位置将文本节点分成两个文本节点substringData(offset,count) 提取从offset位置开始的count个字符串nodeValue.length == data.length == 节点中字符数目123123121—- 第二、第三个 都有文本节点修改文本节点，会自动对文本进行HTML编码( &gt; 变为 &amp;gt )1.创建文本节点document.createTextNode(“hello word!”);创建文本节点，会自动对文本进行HTML编码( &gt; 变为 &amp;gt )，也会为其设置ownerDocument属性。每个元素一般只有一个文本节点，若有多个文本节点且相连的话，那么它们看起来是连起来的。2.规范化文本节点(合并)一个元素有多个文本子节点会很混乱。element.normalize(); 自动将元素中的所有文本子节点合并3.分割文本节点element.firstChild.splitText(5); 在指定位置分割文本节点，返回后面那个文本节点Hello world! ====&gt; “Hello” “ world!”1.5 Comment类型Comment类型 表现 注释。Comment 节点特征：nodeType == 8nodeName == “#comment”nodeValue == 注释值parentNode == Document、Element没有子节点与Text类型继承自相同的基类，拥有除splitText()之外的所有字符串操作方法。同样，nodeValue和data包含的是注释的内容document.createComment(“A comment ”); 创建注释节点1.6 CDATASection类型CDATASection类型 表现CDATA区域(仅XML)继承自Text类型，拥有除splitText()之外的所有字符串操作方法。CDATASection 节点特征：nodeType == 4nodeName == “#cdata-section”nodeValue == CDATA区域中的内容parentNode == Document、Element没有子节点在XML文档中，document.createCDataSection()创建CDATA区域。1.7 DocumentType类型DocumentType类型 包含着与文档的doctype有关的所有信息。(支持度不高)CDATASection 节点特征：nodeType == 10nodeName == doctype的名称nodeValue == nullparentNode == Document没有子节点DocumentType对象保存在document.doctype中。三个属性：name 文档类型的名称entities 由文档类型描述的实体的NamedNodeMap对象 (通常空)notations 由文档类型描述的符号的NamedNodeMap对象 (通常空)&lt;!DOCTYPE HTML PUBLIC “~~” “~~”&gt;document.doctype.name ===&gt; HTML1.8 DocumentFragment类型DocumentFragment类型 表示 文档片段，相当于仓库，需要时可以存起来或者取出来。(在文档中没有对应的标记)DocumentFragment节点特征：nodeType == 11nodeName == “#document-fragment”nodeValue == nullparentNode == null子节点可能：Element、Text、Comment、ProcessingInstruction、CDATASection、EntityReferencedocument.createDocumentFragment() 创建文档片段1.9 Attr类型Attr类型 表示 元素的特性节点Attr节点特征：nodeType == 2nodeName == 特性的名称nodeValue == 特性的值parentNode == null没有子节点Element类型回顾：Attr节点 相当于 attributes属性使用getAttribute()、setAttribute()、removeAttribut()，而很少直接引用特性节点Attr对象三个属性：name 特性名称value 特性值specified 用于设置true指定的/false默认的document.createAttribute(“align”); 创建新的特性节点element.attributes(“align”).value 返回特性节点element.getAttributeNode(“align”).value 返回特性节点element.getAttribute(“align”); 返回特性值","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第十章（1）","slug":"《JavaScript高级程序设计》第十章（1）","date":"2017-04-17T16:00:00.000Z","updated":"2018-09-29T04:42:38.000Z","comments":true,"path":"2017/04/18/《JavaScript高级程序设计》第十章（1）/","link":"","permalink":"http://blog.heavenbin.live/2017/04/18/《JavaScript高级程序设计》第十章（1）/","excerpt":"","text":"DOM(文档对象模型)只讲DOM1级1 节点层次DOM将HTML/XML文档 描绘成 一个由多层次节点构成的结构有12种节点类型，每种类型表示文档中不同的信息及标记，且有各自的特点、数据和方法。它们都继承自一个基类型。文档节点(每个文档的根节点)文档元素(文档节点的唯一子节点，html元素)12345678&lt;html lang=\"en\"&gt; ---- 文档元素 &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;1.1 Node类型DOM1提供Node接口，由DOM中所有节点类型实现。它是在JS中是作为Node类型实现的。所有节点类型(12个)都继承自 Node类型 ，它们的nodeType属性表明节点的类型Node.ELEMENT_NODE(1); 元素节点(常用) Element类型Node.ATTRIBUTE_NODE(2); 属性节点 Attr类型Node.TEXT_NODE(3); 文本节点(常用) TEXT类型Node.CDATA_SECTION_NODE(4); CDATA节点 CDATASection类型(仅XML文档)Node.ENTITY_REFERENCE_NODE(5); 实体引用名称节点Node.ENTITY_NODE(6); 实体名称节点Node.PROCESSING_INSTRUCTION_NODE(7); 处理指令节点Node.COMMENT_NODE(8); 注释节点 Comment类型Node.DOCUMENT_NODE(9); 文档节点 Document类型Node.DOCUMENT_TYPE_NODE(10); 文档类型节点 DocumentType类型Node.DOCUMENT_FRAGMENT_NODE(11); 文档片段节点 DocumentFragment类型(仅此没对应标记)Node.NOTATION_NODE(12); DTD声明节点1.nodeName和nodeValue属性不同的节点类型，值也不一样。对于元素节点：nodeName保存标签名，nodeValue保存null。2.节点关系文档树相当于家谱每个节点都有：childNode 所有子节点一个NodeList类数组对象，里面有length属性，DOM结构的变化能够自动反应在这个对象中length属性有些浏览器会计算空白字符。parentNode 父节点firstChild 第一个子节点lastChild 最后一个子节点nextSibling 下一个兄弟节点previousSibling 上一个兄弟节点ownerDocument 指向文档节点 (具有方便性和唯一性)hasChildNodes() 有一或多个子节点则返回true。(比childNode的length好用)3.操作节点appendChild(添加节点) 返回添加的节点在子节点末尾添加一个节点(若改节点在childNode中，则是转移效果)insertBefore(插入节点,参照节点) 在参照子节点的前面 插入 节点replaceChild(替换节点,被替换节点) 在被替换子节点处 替换 节点removeChild(移除节点) 移除 指定 子节点4.其它方法cloneNode(true/false) 复制节点(true深复制/false浅复制，不复制JS部分)normalize() 去除后代中的空文本节点，合并相邻的文本节点。1.2 Document 类型JS通过Document类型 表示 文档HTMLDocument类型 继承 Document类型在浏览器中，document对象是HTMLDocument类型的一个实例，表示整个HTML页面。document对象也是window对象的一个属性。功能：取得与页面有关的信息，操作页面的外观及其底层结构。document节点特征：nodeType == 9nodeName == “#document”nodeValue == nullparentNode == nullownerDocument == null1.文档的子节点子节点可能：DocumentType(&lt;=1) &lt;!DOCTYPE&gt; 最多一个文档类型子节点Element(&lt;=1)最多一个元素子节点ProcessingInstructionComment一些属性documentElement 访问其子节点的快捷方式 都支持childNodes 访问其子节点的快捷方式 本来就有body 指向元素 都支持doctype 指向&lt;!DOCTYPE&gt; 支持不一致，没什么用处位于外的注释 childNodes可以访问 支持不一致，没什么用处document.documentElement == document.childNodes[0] == document.firstChild因为document最多一个元素子节点，所以很少对document进行子节点的操作。2.文档信息四个属性(这些值来源于请求的HTTP头部)title 标题URL 完整URL(不可设置) http://www.wrox.com/WileyCDA/domain 域名(解决跨域问题) www.wrox.com (hostname)referrer 来源页面的URL(不可设置)回顾：若页面包含框架(frames)，则每个框架都拥有自己的window对象，并且保存在frames集合中。若 外部(www.wrox.com)内嵌(p2p.wrox.com) 则无法通信。(跨域安全限制)通过 设置domain = wrox.com ，它们就可以通信了。3.查找元素getElementById(元素ID) 返回对应ID的元素 (不存在返回null 区分大小写 多个则取第一个)getElementsByTagName(元素标签名) 返回对应标签名的元素零或多个元素的NodeList类数组对象(HTMLCollection对象) 动态 不区分大小写 *所有元素someNodeList[0] ===&gt; 后台 someNodeList.item(0);someNodeList[“myImage”] ===&gt; 后台 someNodeList.namedItem(“myImage”);getElementsByName(元素name特性) 返回对应name的元素 其它情况跟标签名相似4.特殊集合提供查找元素的快捷方式，都是返回HTMLCollection对象document.anchors 包含文档所有带name特性的元素。document.links 包含文档所有带href特性的元素document.applets 包含文档所有的元素document.forms document.getElementsByTagName(“from”);document.images document.getElementsByTagName(“img”);5.DOM一致性检测document.implementation 提供检测浏览器实现了DOM的哪些部分的对象。DOM1提供了一个方法：hasFeature( DOM功能名称 , 版本号 )var hasXmlDom = document.implementation.hasFeature(“XML”,”1.0”);返回ture则拥有功能，但是未必跟规范一致。建议结合能力检测6.文档写入write() 将字符串文本写入到输出流writeln() 将字符串文本写入到输出流 (末尾自动 + \\n)open()/close() 打开/关闭 网页的输出流1.3 Element类型JS通过Element类型 表现XML或HTML元素，提供对元素标签名、子节点及特性的访问。HTMLElement类型 继承 Element类型Element 节点特征：nodeType == 1nodeName == 标签名 == tagName(推荐) 值都为大写nodeValue == nullparentNode == Document、Element子节点可能：Element、Text、Comment、ProcessingInstruction、CDATASection、EntityReferencevar div = document.getElementById(“myDiv”);div.tagName == div.nodeName == DIV1.HTML元素所有的HTML元素 都是 由HTMLElement类型或者其子类型来表示。标准特性：id 唯一标识符title 附加说明信息lang 内容的语言代码dir 语言方向(ltr/rtl)className 指定css类不同的HTML元素对应有不同的类型(书上有表P263)，对应相关的特性和方法。基本所有特性都是属性，但自定义特性不是属性。2.取得特性方式一：函数 —- 可以访问自定义特性(data-**)getAttribute() 取得特性 (没有则返回null)方式二：属性 —- 不能访问自定义特性，因为没有提供两类特殊的特性：style —- 函数访问(返回CSS文本) 属性访问(返回一个对象)onclick —- 函数访问(返回代码字符串) 属性访问(返回一个JS函数)结果：开发人员多数都用属性来访问，而函数调用的方式很少使用3.设置特性方式一：函数 —- 存在一些异常行为setAttribute() 设置特性 (没有则创建)方式二：属性 —- 推荐removeAttribute() 彻底删除特性，不常用4.attributes属性attributes里面包含一个NamedNodeMap对象 (类似NodeList类数组对象 动态)里面是元素的所有特性节点 (attr节点)每个特性节点： nodeName特性名称 nodeValue特性值方法：getNamedItem(name) 返回指定特性节点removeNamedItem(name) 移除节点setNamedItem(node) 添加节点item(pos) 返回位于数字pos位置处的节点这些方法很少用(还不如用前面的)，一般用于遍历特性。5.创建元素var div = document.createElement(“div”); 创建元素节点(HTML不区分大小写，XML区分大小写)document.body.appendChild(div); 将元素节点添加到body中6.元素的子节点一般都会算空白符，有两种方式去掉。1234方式一： &lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;方式二： element.childNodes[i].nodeType == 1 判断它是元素节点","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第九章","slug":"《JavaScript高级程序设计》第九章","date":"2017-04-11T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/04/12/《JavaScript高级程序设计》第九章/","link":"","permalink":"http://blog.heavenbin.live/2017/04/12/《JavaScript高级程序设计》第九章/","excerpt":"","text":"客户端检测不同的浏览器的能力不一样( 比如方法和属性不一样 ) BOM不一样，DOM支持度不一样。不到万不得已，就不要使用客户端检测。1 能力检测通过判断出是否有此能力，来决定是否用这个方法或者属性。2 怪癖检测识别浏览器的特殊行为，建议用匿名函数，建议一开始就执行此类检测。3 用户代理检测究极检测方法，不是逼不得已别去用。主要是检测用户代理字符串，也就是请求头，从而确定实际使用的浏览器。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第八章（2）","slug":"《JavaScript高级程序设计》第八章（2）","date":"2017-04-07T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/04/08/《JavaScript高级程序设计》第八章（2）/","link":"","permalink":"http://blog.heavenbin.live/2017/04/08/《JavaScript高级程序设计》第八章（2）/","excerpt":"","text":"BOM(浏览器对象模型)2 location对象location对象：提供当前窗口中文档的有关信息，将URL解析成为独立的片段。window.location 和 document.location 引用的是同一个对象。所有属性hash 返回一个URL的锚部分 —-#firsthost 返回一个URL的主机名和端口 —-b.a.com:88hostname 返回URL的主机名 —-b.a.comhref 返回完整的URL —-http://b.a.com:88/index.php?name=kang&amp;when=2011#first&#39;pathname 返回的URL路径名 —-/index.phpport 返回一个URL服务器使用的端口号 —-88protocol 返回一个URL协议 —-http:search 返回一个URL的查询部分 —-?name=kang&amp;when=20112.1 查询字符串参数写了一个方法来解析查询字符串，使其变成数组。2.2 位置操作位置操作：实则url的改变location.assign() 加载新文档location.reload() 重新加载当前文档 (缓存或者服务器加载)location.replace() 新文档代替当前文档 (指定url后不会有记录，则后退按钮被禁用)location.assign(“http://b.a.com”)window.location = “http://b.a.com”location.href = “http://b.a.com” —-较常用Location.hash/serch/hostname/pathname/port这些属性和方法都可以改变位置，就是重新定义url。3 navigator对象识别客户端浏览器的事实标准，包括浏览器插件、浏览器品牌、………各种信息。可以用来检测浏览器类型3.1 检测插件利用plugins数组，来封装函数，从而检测插件是否安装。3.2 注册处理程序让一个站点指明它可以处理特定类型的信息。registerContentHandler( MIME， URL， 应用程序名称 )registerProtocolHandler( 协议，URL，应用程序名称 )4 screen 对象screen对象：用处不大，包括浏览器窗口外部的显示器的信息(屏幕)。有时候可能用来调整浏览器窗口大小。5 history 对象history对象：保存着用户上网的历史记录。history.go() 加载 history 列表中的某个具体页面history.back() 加载 history 列表中的前一个 URLhistory.forward() 加载 history 列表中的下一个 URLhistory.length 返回历史列表中的网址数","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第八章（1）","slug":"《JavaScript高级程序设计》第八章（1）","date":"2017-04-02T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/04/03/《JavaScript高级程序设计》第八章（1）/","link":"","permalink":"http://blog.heavenbin.live/2017/04/03/《JavaScript高级程序设计》第八章（1）/","excerpt":"","text":"BOM(浏览器对象模型)1 window对象BOM的核心对象是window对象，双重角色(访问浏览器的一个接口/ECMAScript规定的Global对象)1.1 全局作用域访问调用时可以去掉window：age —- window.agesayAge() —- window.sayAge()window创建的好处 可以用delete操作符删除(其它不行) delete window.color;window的用处 查询变量是否存在(若没有window，值undefined会报错) var newValue = window.oldValue;1.2 窗口关系及框架若页面包含框架(frames)，则每个框架都拥有自己的window对象，并且保存在frames集合中。通过数值索引(从0开始，从左到右，从上到下)或者框架名称来访问相应的window对象。window.frames[0/“topFrame”] top.frames[0/“topFrame”] frames[0/“topFrame”]window.frames[1/“leftFrame”] top.frames[1/“leftFrame”] frames[1/“leftFrame”]window.frames[2/“rightFrame”] top.frames[2/“rightFrame”] frames[2/“rightFrame”]top对象 最高(最外)层的框架，也就是浏览器窗口parent对象 当前框架的直接上层框架self对象 window对象1.3 窗口位置screenLeft screenX 相对屏幕左边的距离screenTop screenY 相对屏幕上边的距离moveTo(x,y坐标值) moveBy(水平，垂直像素数) 窗口移动值(只能对最外层window对象使用)1.4 窗口大小outerWidth outerHeight 返回浏览器窗口本身的尺寸innerWidth innerHeight 容器中页面视图去的大小(减去边框宽度)resizeTo(100,100) 新宽度100，新高度100 (只能对最外层window对象使用)resizeBy(100,50) 宽度增加100，高度增加50 (只能对最外层window对象使用)1.5 导航和打开窗口window.open() 打开窗口或者弹出窗口 返回指向新窗口的对象，和window对象大致相似四个参数：URL 窗口目标 特性字符串 新页面是否取代浏览器历史记录中当前加载页面的布尔值 (通常只传1和4)窗口目标：窗口或框架名称 / _self / _parent / _top / _blank1.弹出窗口特性字符串：fullscreen、height、location、….新窗口的设置 (不打开新窗口，会忽略这个参数)var wroxWin = window.open(“http:…”,“wroxWindow”,“height=400,widht=400,top=10,…”)wroxWin.close() 关闭窗口wroxWin.opener 原始窗口对象(原始窗口独有)2.安全限制一些弹窗广告的问题3.弹出窗口屏蔽程序弹出窗口被屏蔽了，2种可能性：浏览器内置阻止 open()返回null扩展程序阻止 open()报错1.6 间歇调用和超时调用超时调用setTimeout( 代码字符串/函数，毫秒数 ) 毫秒数不准(JS是单线程的解释器，有JS任务队列，毫秒数到后就加入任务队列)clearTimeout( setTimeout返回的ID )间歇调用setInterval( 代码字符串/函数，毫秒数 )clearInterval( setInterval返回的ID )最佳实践是用超时调用模拟间歇调用，最好不要使用间歇调用。(因为后一个间隙调用可能会在前一个间隙调用结束之前启动)1.7 系统对话框alert(“Hello world!”) 警告框 向用户显示信息confirm(“Are you sure?”) 确认框 让用户决定是否执行给定操作prompt(“What’s your name?”, “Michael”) 提示框 让用户输入文本信息print(); 打印对话框find(); 查找对话框Google Chrome新特性：从第二个对话框开始，浏览器会给个复选框来阻止后续的对话框。(预防无限弹窗)","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第七章（2）","slug":"《JavaScript高级程序设计》第七章（2）","date":"2017-03-29T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/03/30/《JavaScript高级程序设计》第七章（2）/","link":"","permalink":"http://blog.heavenbin.live/2017/03/30/《JavaScript高级程序设计》第七章（2）/","excerpt":"","text":"函数表达式3 模仿块级作用域for(var i=0;i&lt;10;i++) 里面的i变量在循环结束后，没有被销毁，仍然能被访问到。所以需要模仿块级作用域(私有作用域)来解决这个问题。(function(){ //块级作用域 })();function outputNumbers(count){(function(){ //块级作用域 == 立即执行匿名函数 == 闭包(这个闭包执行完毕会立即销毁其作用域链)for(var i=0;i&lt;count;i++){alert(i);}})();alert(i);}作用：1.解决变量i被访问的问题，能够内部自己销毁掉，同时这种闭包会立即销毁作用域链。2.匿名自执行函数可以减少污染全局方法和属性。4 私有变量ECMAScript没有私有成员的概念：所有对象属性都是公有的，但是有私有变量的概念。私有变量：函数的参数、局部变量、函数内部定义的其它函数。闭包 就可以通过自己的作用域链访问到 函数的私有变量。特权方法：有权访问私有变量和私有函数的公有方法。两种在对象上创建特权方法的方式：方式一：在构造函数中定义特权方法function Person(name){this.getName = function(){ return name; }; 特权方法/闭包this.setName = function(value){ name = value; }; 特权方法/闭包}特点：构造函数会重复创建相同的一组新方法，占内存 + 每个实例的私有变量不一样方式二：在私有作用域中定义构造函数，在原型中定义特权方法7.4.1特点：增进代码重用性 + 所有实例共享私有变量(静态私有变量)4.1 静态私有变量在私有作用域中定义构造函数，在原型中定义特权方法(function(){ 私有作用域var name = “”; 私有变量Person = function(value){ name = value }; 全局构造函数Person.prototype.getName = function(){ return name; } 在原型中创建特权方法Person.prototype.setName = function(value){ name = value; } 在原型中创建特权方法})();var person1 = new Person(“Nicholas”);person1.setName(“Greg”);var person2 = new Person(“Nicholas”);alert(person1.getName()); // Nicholas 共享私有变量增进了代码的重用性，但是每个实例共享私有变量。(因为这个叫静态私有变量)使用实例变量，还是静态私有变量，看具体需求。4.2 模块模式前面的模式是用于为自定义类型创建私有变量和特权方法的。模块模式：为单例创建私有变量和特权方法。(单例：只有一个实例的对象)var app = function(){var components = new Array(); //私有变量和函数components.push(new BaseComponent()); //代表一些初始化操作return {getComponentCount: function(){ //特权方法return components.length;},….}}使用场景：创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法。web应用程序中，经常需要使用单例来管理应用程序级的信息。4.3 增强的模块模式var app = function(){var components = new Array(); //私有变量和函数components.push(new BaseComponent()); //代表一些初始化操作return {getComponentCount: function(){ //特权方法return components.length;},….}var app = new BaseComponent(); //必须是某种类型的实例app.getComponentCount = function(){ //必须添加某些属性或方法(特权方法)return components.length;};…return app; //返回BaseComponent的实例app}使用场景：单例必须是某种类型的实例，同时还必须添加某些属性或方法情况增强的模块模式、模块模式的区别在于命名变量app的创建过程4.4 总结私有变量实现自定义类型的特权方法：构造函数模式、原型模式实现单例的特权方法：模块模式、增强的模块模式","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第七章（1）","slug":"《JavaScript高级程序设计》第七章（1）","date":"2017-03-25T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/03/26/《JavaScript高级程序设计》第七章（1）/","link":"","permalink":"http://blog.heavenbin.live/2017/03/26/《JavaScript高级程序设计》第七章（1）/","excerpt":"","text":"函数表达式函数声明 function sum(num1,num2) { return num1 + num2; } sum.name = “sum”函数表达式 var sum = function(num1,num2){ return num1 + num2; } sum.name = “” 所以也叫 匿名函数var sum = new Function(“num1”,“num2”,“return num1 + num2”); (不推荐，性能不好)函数声明提升： 解析器会率先读取函数声明，可以使其在执行任何代码之前可用。函数表达式不会提升： 必须等到解析器执行到它所在的代码行，才会被解析执行。匿名函数的用途：？1 递归严格模式不能用 arguments.callee，可以用命名函数表达式来解决递归问题var factorial = (function f(num){if(num &lt;= 1){ return 1; }else{ return num*f(num-1); }});2 闭包闭包 —- 有权访问另一个函数作用域中的变量的函数function createComparisonFunction(propertyName){return function(object1,object2){ —- 闭包(匿名函数)var value1 = object1[propertyName]; —- 能够访问另一个函数的内部变量var value1 = object2[propertyName]; —- 能够访问另一个函数的内部变量if(value1 &lt; value2){ return -1; }else if(value1 &gt; value2){ return 1; }else{ return 0; }}}var compareNames = createComparisonFunction(“name”); //创建函数var result = compareNames( {name:“Nicholas”} , {name:“Greg”} ); //调用函数compareNames = null; //销毁匿名函数创建函数后返回闭包，createComparisonFunction的作用域链被销毁，但是它的活动对象仍然会留在内存中，直到匿名函数被销毁createComparisonFunction自己的活动对象{arguments:[“name”]propertyName:“name”}全局变量对象compareNames自己的活动对象{arguments:[{name:“Nicholas”} , {name:“Greg”}]object1:{name:“Nicholas”}object2:{name:“Greg”}}createComparisonFunction的活动对象{ —- 因为访问了另一个函数，所以它的活动对象也跟进来了arguments:[“name”]propertyName:“name”}全局变量闭包作用(闭包是函数，一般用匿名函数，创建方式通常是函数中有函数)1.闭包可以访问返回另一个函数内部的变量。 访问功能2.另一个函数的活动对象会被保存，直到闭包的作用域链被销毁。 保存功能注意：只在绝对必要时再考虑使用闭包。2.1 闭包和变量副作用：闭包的作用域链上保存的是整个变量对象，所以返回的变量是保存的最后一个值。function createFunction(){var result = new Array();for(var i=0; i&lt;10; i++){result[i] = function(){ return i; }; —- 这个闭包的i保存的是最后一个值 10}return result;}使用立即执行匿名函数可以解决这个问题result[i] = function(num){return function(){ return num; };}(i);2.2 关于this对象var name = “The Window”;var object = {name: “My Object”,getNameFunc: function(){return function(){ —- 闭包return this.name; —- 闭包中用了this};}};object.getNameFunc()() //“The Window” —- 有些情况会出现问题这种写法还不错：getNameFunc: function(){var that = this;return function(){return that.name;};}闭包中的this对象，闭包可能在某些特殊情况被放到全局对象上，从而this变却不自知。所以别乱用this。2.3 内存泄漏指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。使用闭包，确保正常回收内存","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第六章（3）","slug":"《JavaScript高级程序设计》第六章（3）","date":"2017-03-19T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/03/20/《JavaScript高级程序设计》第六章（3）/","link":"","permalink":"http://blog.heavenbin.live/2017/03/20/《JavaScript高级程序设计》第六章（3）/","excerpt":"","text":"面向对象的程序设计3 继承两种继承方式：接口继承、实现继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。3.1 原型链利用原型链继承实现原型链的本质是重写原型对象 ( 原型对象 == 构造函数的实例 )例如：Object构造函数的实例 赋值给 SuperType的原型对象 ==== Object 的函数和属性SuperType构造函数的实例 赋值给 SubType的原型对象 ==== Object + SuperType 的函数和属性SubType构造函数的实例 为 instance ==== Object + SuperType + SubType 的函数和属性原型搜索机制：1.搜索实例 2.搜索实例的原型 3.搜索实例的原型的原型 … 4.直到原型链末端1.别忘了默认的原型所有函数的默认原型都是Object的实例。所以应该除Object之外的构造函数也是实例，有constructor也有[[prototype]]2.确定原型和实例的关系instanceof isPrototypeOf() 都是检测是否在原型链上3.谨慎地定义方法必须在实例替换原型之后才能定义新的方法。不要使用字面量添加新方法，不然会换一个对象。4.原型链的问题无法继承实例属性，因为不能传递参数在创造子类型(new)的实例时，不能向超类型的构造函数中传递参数。所以很少单独使用原型链。3.2 借用构造函数借用构造函数继承function SuperType(name) {this.name = name;}function SubType() {SuperType.call(this); —- 继承了SuperType}1.传递参数SuperType.call(this,“Nicholas”); —- 继承了SuperType，同时还传递了参数2.借用构造函数的问题方法都在构造函数中定义，函数复用就无从谈起。(占空间)超类型的原型中定义的方法，子类型是不可见的。也很少单独使用。3.3 组合继承原型链 实现 原型属性和方法的继承 老样子借用构造函数 实现 实例属性的继承 传递参数原型属性 == 固定了的实例属性 == 可以通过传参定制function SuperType(name){this.name = name;this.colors = [“red”,“blue”]; —- 继承的原型属性}SuperType.prototype.sayName = function() { alert(this.name); }; —-继承的原型方法function SubType(name,age){SuperType.call(this,name); —- 借用构造函数继承(传递参数继承实例的属性)this.age = age;}SubType.prototype = new SuperType(); —- 原型链继承SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() { alert(this.age); };var instance = new SubType(“Nicholas”,29); —- 这里就不算继承了，是最终的实例了最常用的继承方式 但是有缺陷(寄生组合式继承解决)instanceof isPrototypeOf() 都能够识别3.4 原型式继承var person = {name: “Nicholas”, —- 基本类型值friends: [“Van”] —- 引用类型值};var anotherPerson = object(person); anotherPerson.friends.push(“Rob”);var yetAnotherPerson = object(person); yetAnotherPerson.friends.push(“Barbie”);alert(person.friends); //Van,Rob,Barbie —- 引用类型值会共享使用场景：只是想让一个对象与另一个对象保持类似的情况。ES5提供Object.create()方法规范化了原型式继承。写法1： var anotherPerson = Object.create(person); anotherPerson.name = “Greg”写法2： var anotherPerson = Object.create(person, { name:{value:“Greg”} });3.5 寄生式继承与原型式继承紧密相关的一种思路，思路与寄生构造函数和工厂模式类似。function createAnother(original){var clone = object(original);clone.sayHi = function() { alert(“hi”); }; —- 大哥的函数和属性return clone;}var person = { —- 小哥的函数和属性name: “Nicholas”,friends: [“Van”]};var anotherPerson = createAnother(person); —- 寄生式继承 (给人一种叠加的感觉，相当于1+1 没有函数复用)anotherPerson.sayHi(); //Hi使用场景：主要考虑对象而不是自定义类型和构造函数的情况下，可以用用。3.6 寄生组合式继承组合继承有问题：调用了两次超类型的构造函数，导致实例和原型中重复了属性。SubType.prototype = new SuperType(); 第一次调用SuperType.call(this,name); 第二次调用导致 SubType的实例instance拥有name：“Nicholas” SubType.prototype 也有 name: (undefined)解决方案：使用寄生式继承 来 继承超类型的原型function inheritPrototype(subType,superType){var prototype = object(superType.prototype);prototype.constructor = subType;subType.prototype = prototype;}寄生组合式继承最终写法：function SuperType(name){this.name = name;this.colors = [“red”,“blue”]; —- 继承的原型属性}SuperType.prototype.sayName = function() { alert(this.name); }; —-继承的原型方法function SubType(name,age){SuperType.call(this,name); —- 借用构造函数继承(传递参数继承实例的属性)this.age = age;}SubType.prototype = new SuperType(); —- 原型链继承SubType.prototype.constructor = SubType;inheritPrototype(subType,superType); —- 使用寄生式继承 来 继承超类型的原型SubType.prototype.sayAge = function() { alert(this.age); };var instance = new SubType(“Nicholas”,29); —- 这里就不算继承了，是最终的实例了寄生组合式继承解决了这个问题，成为了最理想的继承范式。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第六章（2）","slug":"《JavaScript高级程序设计》第六章（2）","date":"2017-03-15T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/03/16/《JavaScript高级程序设计》第六章（2）/","link":"","permalink":"http://blog.heavenbin.live/2017/03/16/《JavaScript高级程序设计》第六章（2）/","excerpt":"","text":"面向对象的程序设计2 创建对象2.4 组合使用构造函数模式和原型模式最常见的模式，实例有自己的属性和方法，也有共享的。function Person(name){ this.name = name; }Person.prototype = {constructor: Person,sayName: function(){ alert(this.name); }}可以说这是用来定义引用类型的一种默认模式2.5 动态原型模式在上面的模式再加一个判断语句，来动态在原型中加入方法。if(typeof this.sayName != “function”){Person.prototype.sayName = function() { alert(this.name); }}2.6 寄生构造函数模式工厂模式 + 普通-&gt;构造 + 用new操作符function Person(name){var o = new Object();o.name = name;o.sayName = function() {alert(this.name);};return o;}var friend = new Person(“Nicholas”);这个模式可以在特殊情况下用来为对象创建构造函数返回的对象和构造函数没有关系，导致不能用instanceof操作符来确定对象的类型。不要使用这种模式2.7 稳妥构造函数模式跟寄生构造函数模式类似的模式它们区别：1.实例方法不引用this 2.不适用new调用构造函数function Person(name){var o = new Object();o.sayName = function() { alert(name); };return o;}var friend = Person(“Nicholas”);friend.sayName(); —- 除了调用sayName()之外无法拿到name数据，这种模式比较安全，但是instanceof也检测不出","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第六章（1）","slug":"《JavaScript高级程序设计》第六章（1）","date":"2017-03-12T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/03/13/《JavaScript高级程序设计》第六章（1）/","link":"","permalink":"http://blog.heavenbin.live/2017/03/13/《JavaScript高级程序设计》第六章（1）/","excerpt":"","text":"面向对象的程序设计每个对象都是基于一个引用类型创建的1 理解对象原始构造方式var person = new Object();person.name = “Nicholas”;person.sayName = function(){ alert(this.name); };对象字面量var person = {name: “Nicholas”,sayName: function(){ alert(this.name); }};1.1 属性类型1.数据属性4个特性[[Configurable]] 默认true 能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者改为访问器属性。[[Enumerable]] 默认true 能否通过for-in循环返回属性。[[Writable]] 默认true 能否修改属性的值[[Value]] 默认undefined 属性的数据值Object.defineProperty(所在对象，属性值的名字，描述符对象[特性]) 可用于定义或修改属性2.访问器属性不包含数据值4个特性[[Configurable]] 默认true 能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者改为访问器属性。[[Enumerable]] 默认true 能否通过for-in循环返回属性。[[Get]] 默认undefined 读取属性时调用的函数。[[Set]] 默认undefined 写入属性时调用的函数。必须通过Object.defineProperty()才能定义访问器属性。1.2 定义多个属性Object.defineProperties(所在对象，属性值的名字{描述符对象[特性]}) 可以是数据属性，也可以是访问器属性。1.3 读取属性的特性Object.getOwnPropertyDescriptor(所在对象，属性值的名字)2 创建对象Object构造函数和对象字面量方式可以创建单个对象，但是创建多个对象会产生大量的重复代码。2.1 工厂模式ECMAScript没有类，发明一种函数来封装以特定接口创建对象的细节。function createPerson(name){var person = new Object();person.name = name;person.sayName = function(){ alert(this.name); };return person;}var person1 = createPerson(“Nicholas”); —- 调用普通函数缺点：无法得知对象的类型2.2 构造函数模式原生构造函数：Object()、Array()自定义构造函数：Person() —- 构造函数都是大写function Person(name){this.name = name;this.sayName = function(){ alert(this.name); };}var person1 = new Person(“Nicholas”); —- 调用new + 构造函数new操作符创建对象经历4个步骤：1.创建一个新对象； var person = new Object();2.将构造函数的作用域赋给新对象； this ==&gt; person3.执行构造函数中的代码；4.返回新对象。 return person;构造函数创建的对象的属性：constructor(构造函数) ==&gt; 它的构造函数 这样就能得知对象的类型person1 instanceof Object //trueperson1 instanceof Person //true1.将构造函数当做函数var person = new Person(“Nicholas”); 当做构造函数person.sayName(); //NicholasPerson(“Greg”); 当做普通函数window.sayName(); //Gregvar o = new Object();Person.call(o,“Kristen”); 在另一个对象的作用域中调用o.sayName(); //Kristen2.构造函数的问题当创建多个对象时，sayName()这个函数将重复占用空间。所以得像下面这样写：function Person(name){this.name = name;this.sayName = sayName;}function sayName(){ alert(this.name); }; —- 缺点：这个是全局函数了，没有封装性可言2.3 原型模式1.理解原型对象每个函数(包括构造函数) —- prototype ==&gt; 函数的原型对象构造函数的实例 —- [[prototype]] ==&gt; 函数的原型对象每个原型对象 —- constructor ==&gt; 它的构造函数[[prototype]] 无法访问，部分浏览器提供了protoisPrototypeOf() 测试实例是否拥有其原型对象的指针Person.prototype.isPrototypeOf(person1); //truePerson.prototype.isPrototypeOf(person2); //trueObject.getPrototypeOf() ES5提供了访问[[prototype]]的接口Object.getPrototypeOf(person1) == Person.prototype //trueObject.getPrototypeOf(person1).name //Nicholas实例的属性会屏蔽原型对象中保存的同名属性hasOwnProperty() 判断这个属性是否存在对象(实例)中，否则在原型中person1.hasOwnProperty(“name”) //true2.原型与in操作符单独使用inhasOwnProperty() + in ==== 100%确定该属性存在对象还是原型中person1.hasOwnProperty(“name”) 存在对象还是原型 “name” in person1 保证有name这个属性for-in循环constructor prototype 的特性是不可枚举的，所以for-in枚举不出来。Object.key(Person.prototype); //name 除了不可枚举Object.getOwnPropertyNames(Person.prototype); //name,constructor 包括不可枚举3.更简单的原型语法function Person(){}Person.prototype = {constructor: Person, —- 这个必须写，这种语法相当于重写原型，不写这行那么属性将指向Objectname: “Nicholas”,sayName: function() { alert(this.name); }}这种方式 constructor的可枚举性则变为true，可以用Object.defineProerty()改回来4.原型的动态性实例与原型之间的连接只不过是一个指针。原型修改成另外一个对象 ==== 切断构造函数与最初原型之间的联系 —- 所以不建议这种写法 Person.prototype = {…}已经创建的实例指针还在连接之前的原型5.原生对象的原型所有原生对象的引用类型(Object,Array…)都是这种模式创建的。所以可以添加自定义的函数和属性，但是不推荐(可能会重写覆盖原型)6.原型对象的问题单纯用原型对象的话，没有属于实例自己独有的属性","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第五章（4）","slug":"《JavaScript高级程序设计》第五章（4）","date":"2017-03-10T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/03/11/《JavaScript高级程序设计》第五章（4）/","link":"","permalink":"http://blog.heavenbin.live/2017/03/11/《JavaScript高级程序设计》第五章（4）/","excerpt":"","text":"引用类型7 单体内置对象前面介绍的都是内置对象，而这两个是单体内置对象：Global、Math7.1 Global对象所有在全局作用域中定义的属性和函数，都是Global对象的属性。1.URL编码方法URL(通用资源标识符)编码 encodeURI() 整个(除特殊字符) encodeURIComponent() 某一段(包括特殊字符)解码 decodeURI() 整个(除特殊字符) decodeURIComponent() 某一段(包括特殊字符)2.eval()方法eval(“alert(‘hi’)”); ==== alert(“hi”);相当于ECMAScript解析器，但是外部访问不到创建的变量和函数非常强大也非常危险，需要非常谨慎地使用。会有代码注入的风险3.Global对象的属性特殊值：undefined、NaN、Infinity构造函数：Object、Array、Function、Boolean、String、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、StyntaxError、TypeError、URIError4.window对象Web浏览器是将Global对象作为window对象的一部分加以实现的 (就理解为相同吧)7.2 Math对象Math对象：保存数学公式和信息1.Math对象的属性Math.E 自然对数的底数，即常量e的值Math.LN10/Math.LN2 10的自然对数/2的自然对数Math.LOG2E/Math.LOG10E 以2为底e的对数/以10为底e的对数Math.PI πMath.SQRT1_2 1/2的平方根Math.SQRT2 2的平方根2.min()和max()方法一组数值的最小值和最大值3.舍入方法小数值变整数Math.ceil(25) 进一Math.floor(25) 退一Math.round(25) 四舍五入4.random()方法[0,1) 之间的随机数5.其它方法Math.abs(num) 返回num的绝对值Math.exp(num) 返回Math.E的num次幂Math.log(num) 返回num的自然对数Math.pow(num,power) 返回num的power次幂Math.sqrt(num) 返回num的平方根Math.acos(x) 返回x的反余弦值Math.asin(x) 返回x的反正弦值Math.atan(x) 返回x的反正切值Math.atan2(y,x) 返回y/x的反正切值Math.cos(x) 返回x的余弦值Math.sin(x) 返回x的正弦值Math.tan(x) 返回x的正切值","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第五章（3）","slug":"《JavaScript高级程序设计》第五章（3）","date":"2017-03-06T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/03/07/《JavaScript高级程序设计》第五章（3）/","link":"","permalink":"http://blog.heavenbin.live/2017/03/07/《JavaScript高级程序设计》第五章（3）/","excerpt":"","text":"引用类型6 基本包装类型 (特殊的引用类型)3个特殊的引用类型：Boolean Number String 目的是方便操作基本类型值var s1 = “some text”;var s2 = s1.substring(2); var s1 = new String(“some text”); 执行瞬间会自动创建基本包装类型的对象var s2 = s1.substring(2);s1 = null; 执行之后立即销毁，所以不能添加属性方法基本包装类型 vs 普通的引用类型 —- 对象的生存期var s1 = new Object(“some text”); ==== var s1 = new String(“some text”);6.1 Boolean类型var booleanObject = new Boolean(false); 布尔值对应的引用类型var booleanValue = true; 布尔值重写valueOf() 返回基本类型值true/false重写toString() 返回字符串“true”/“false”坑1 布尔表达式中 对象都为true booleanObject &amp;&amp; booleanValue ==== true坑2 typeof booleanObject ==== objecttypeof booleanValue ==== boolean坑3 booleanObject instanceof Boolean ==== truebooleanValue instanceof Boolean ==== true建议永远不要使用Boolean对象6.2 Number类型var numberObject = new Number(10); 数字值对应的引用类型var numberValue = 10; 数字值重写valueOf() 返回基本类型的数值重写toLocaleString() 返回字符串形式的数值重写toString() 返回字符串形式的数值toFixed() 返回指定小数位数的数值的字符串toExponential() 返回指定小数位数的数值的字符串 (e表示法)toPrecision() 返回指定所有位数(不包括e)的数值的字符串坑1 typeof numberObject ==== objecttypeof numberValue ==== number坑2 numberObject instanceof Number ==== truenumberValue instanceof Boolean ==== true也建议不要直接实例化Number类型。6.3 String 类型var stringObject = new String(“hello world”); 字符串对应的引用类型 length === 11var stringValue = “hello world”; 字符串 length === 11valueOf() 返回对象所表示的基本字符串值toLocaleString() 返回对象所表示的基本字符串值toString() 返回对象所表示的基本字符串值1.字符方法charAt()/stringValue[] 返回对应字符charCodeAt() 返回对应字符编码2.字符串操作方法concat() / + 操作符 和数组的concat()看起来一样slice() substring() substr() 截取字符串，三个很灵活3.字符串位置方法indexOf() lastIndexOf()4.trim()方法trim() 删除前置及后缀的所有空格trimLeft()trimRight()5.字符串大小写转换方法toLowerCase() toUpperCase() 经典方法toLocaleLowerCase() toLocaleUpperCase() 特定地区 这种更加稳妥6.字符串的模式匹配方法match() 和RegExp的exec()本质一样 返回匹配到字符串的数组search() 返回第一个匹配项的索引 否则返回-1replase() 匹配且替换字符串split() 匹配分隔符生成数组7.localeCompare()方法localeCompare() 比较两个字符串8.fromCharCode()方法fromCharCode()静态方法 将多个字符编码变成字符串9.HTML方法例如： big() 输出 string尽量不使用","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第五章（2）","slug":"《JavaScript高级程序设计》第五章（2）","date":"2017-03-04T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/03/05/《JavaScript高级程序设计》第五章（2）/","link":"","permalink":"http://blog.heavenbin.live/2017/03/05/《JavaScript高级程序设计》第五章（2）/","excerpt":"","text":"引用类型3 Date类型new Date()Date.parse(“May 25,2004”)Date.UTC(2005,0)Date.now()3.1 继承的方法toLocaleString()toString()valueOf()3.2 日期格式化方法toDateString()toTimeString()toLocaleDateString()toLocaleTimeString()toUTCString()3.3 日期/时间组件方法4 RegExp类型字面量 var pattern1 = / [bc]at / i; 单重转义 /.at/构造函数 var pattern2 = new RegExp(“[bc]at”,“i”); 双重转义 \\.at正则表达式 [bc]at标志(1~n) g 全部都匹配 i不区分大小写 m多行模式元字符 ( [ { \\ ^ $ | ) ? * + . ] }4.1 RegExp实例属性global 布尔值 是否设置了g标志ignoreCase 布尔值 是否设置了i标志lastIndex 整数 开始搜索下一个匹配项的字符位置，从0算起multiline 布尔值 是否设置了m标志source 正则表达式的字符串表示没什么卵用4.2 RegExp实例方法exec() 捕获组(捕获多组匹配项)text() 一次看是否匹配4.3 RegExp构造函数属性有点多，用来看最近一次匹配的相关信息4.4 模式的局限性缺少某些语言(Perl)所支持的高级正则表达式特性，但是绝大多数情况够用5 Function类型函数 —- 对象(也是Function的实例)函数名 —- 指针 —- 变量函数声明 function sum(num1,num2) { return num1 + num2; }函数表达式 var sum = function(num1,num2){ return num1 + num2; }var sum = new Function(“num1”,“num2”,“return num1 + num2”); (不推荐，性能不好)5.1 没有重载(深入理解)在创建第二个函数时，实际上覆盖了引用第一个函数的变量。5.2 函数声明与函数表达式函数声明提升： 解析器会率先读取函数声明，可以使其在执行任何代码之前可用。函数表达式不会提升： 必须等到解析器执行到它所在的代码行，才会被解析执行。5.3 作为值的函数函数 可以作为 函数的参数/函数的返回5.4 函数内部属性arguments对象[callee —- 自身函数(常用于递归函数)caller —- 没说]this对象 —- 函数执行的环境对象caller —- 调用当前函数的函数(如果是全局作用域的函数则值为null)5.5 函数属性和方法length 声明参数个数prototype 实现继承(不可枚举)非继承方法：a.apply( 运行函数的作用域 , 类数组/数组 ) 扩充作用域 相当于 修改函数内部的this值a.call( 运行函数的作用域 , 值 , 值 , … ) 扩充作用域 相当于 修改函数内部的this值var b = a.bind( 对象/值 ) 为函数创建实例 相当于 b函数 = a函数的this值绑定给参数","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第五章（1）","slug":"《JavaScript高级程序设计》第五章（1）","date":"2017-03-02T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/03/03/《JavaScript高级程序设计》第五章（1）/","link":"","permalink":"http://blog.heavenbin.live/2017/03/03/《JavaScript高级程序设计》第五章（1）/","excerpt":"","text":"引用类型引用类型 ~= 对象定义 (对象是某个特定引用类型的实例)var person = new Object(); —-new + 构造函数(本身是函数，因为构造了实例所以叫构造函数)person对象是被Object引用类型创建的一个实例1 Object类型new + 构造函数 var parson = new Object();对象字面量 var person = {};(适合给函数传入大量参数，不会调用Object函数)点表示法 person.name (推荐)方括号表示法 person[“name”]var propertyName = “name”;personpropertyNameObject是一个基础类型，其他所有类型都从Object继承了基本的行为。2 Array类型ECMAScript特殊： 数组的每一项可以保存任何类型的数据。new + 构造函数 var colors = new Array(); new可省略Array(); Array(20); Array(“red”,“blue”);数组字面量 var colors = [*];[]; [1,2]; [“red”,“blue”];访问 colors[] = **; colors.length妙用length var colors = [“red”,“blue”,“green”];colors.length = 2; alert(colors[2]); //undefinedcolors.length = 4; alert(colors[3]); //undefinedcolors[colors.length] = “black”; colors[colors.length] = “brown”;colors[99] = “black”; alert(colors.length); //1002.1 检测数组12345instanceof if(value instanceof Array) &#123;~~~~&#125;Array.isArray() if(Array.isArray(value)) &#123;~~~~&#125; //(推荐)2.2 转换方法toString() 每个值的字符串形式 拼接成 以逗号分割的字符串 alert(),sort()valueOf() 每个值的原始形式 拼接成 数组 a + btoLocaleString() 每个值调用toLoc… 拼接成 以逗号分割的字符串join(1) 每个值间隔为参数 拼接成 以参数分割的字符串参数是 空 / undefined 则用 逗号项值是 null / undefined 则用 空字符串2.3 栈方法(后进先出)push(n) 在数组尾部添加n个新项 有改变 返回新的数组pop() 在数组尾部删除1个项 有改变 返回删除的项2.4 队列方法(先进先出)shift() 在数组头部删除1个项 有改变 返回删除的项unshift(n) 在数组头部添加n个新项 有改变 返回新的数组2.5 重排序方法reverse() 反转数组顺序 有改变sort() 每项toString()后比较字符串的形式升序数组 有改变可加入比较函数这个参数，可自定义比较方法2.6 操作方法concat(n) 在数组尾部添加n个数组的每一项 原没变 (参数不是数组则相当于push)slice() 原没变 截取段splice(1,2,3) 原变了 可删可添2.7 位置方法两个参数：查找的项 查找的起点索引比较用全等操作符===indexOf(1,2) 顺序查找 返回索引 一个参数则默认头部开始lastIndexOf(1,2) 反序查找 返回索引 一个参数则默认尾部开始2.8 迭代方法两个参数： 要在每一项上运行的函数 运行该函数的作用域对象运行的函数的三个参数： 数组项的值 项的索引 数组对象本身原数组不会变every(1,2) 每一项都true，则返回truesome(1,2) 有一项为true，则返回truefilter(1,2) 返回true的项组成的数组forEach(1,2) 没有返回值map(1,2) 结果组成数组2.9 并归方法两个参数： 要在每一项上调用的函数 作为并归基础的初始值运行的函数的四个参数： 前一个值(前一个的结果值) 当前值 项的索引 数组对象reduce(1,2) 顺序reduceRight(1,2) 反序","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第四章","slug":"《JavaScript高级程序设计》第四章","date":"2017-02-25T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/02/26/《JavaScript高级程序设计》第四章/","link":"","permalink":"http://blog.heavenbin.live/2017/02/26/《JavaScript高级程序设计》第四章/","excerpt":"","text":"变量、作用域和内存问题1 基本类型和引用类型的值基本类型值：简单的数据段 按值访问(包括5种基本数据类型) 保存在栈内存引用类型值：可能由多个值构成的对象 按引用访问(添加属性时除外) 保存在堆内存1.1 动态的属性var person = new Object();person.name = “Nicholas”;alert(person.name); //Nicholasvar person = “Nicholas”person.age = 27;alert(person.age); //undefined只能给引用类型值动态地添加属性1.2 复制变量值var num1 = 5;var num2 = num1;基本类型值 赋值操作 分配在不同的空间var obj1 = new Object();var obj2 = obj1;obj1.name = “Nicholas”;alert(obj2.name); //Nicholas引用类型值 赋值操作 引用同一个空间 (实际赋值的是指针)1.3 传递参数基本类型值 传入函数里修改 不会改变 分配在不同的空间引用类型值 传入函数里修改 会改变 引用同一个空间(堆内存)1.4 检测类型alert(typeof s); s变量的数据类型是什么？alert(person instanceof Object); person的数据类型是Object吗？2 执行环境及作用域宿主环境(浏览器) 决定 全局执行环境(window对象)执行环境 对应一个 变量对象当代码在一个环境执行时，会创建变量对象的一个作用域链。执行过程中活动对象也在不断变化。标识符解析：沿着作用域链一级一级地搜索标识符的过程。(逐级往后搜索)例如：函数(执行环境)活动对象(变量对象) arguments ==&gt; arguments + 其它变量作用域链(当前变量对象–外部变量对象–再外部变量对象–全局变量对象) – 可用于标识符解析windowcolorchangeColor() changeColor() – 全局变量对象anotherColorswapColors() swapColors() – changeColor() – 全局变量对象tempColor2.1 延长作用域链执行环境类型：全局、局部(函数)With语句： 作用域前端 添加 指定对象catch语句： 作用域前端 创建 被抛出的错误对象2.2 没有块级作用域没有块级作用域：由{}这种花括号封闭的代码块没有自己的作用域if(true){ var color = “blue”; }alert(color); //“blue”for(var i=0;i&lt;10;i++){ doSomething(i); }alert(i); //10声明变量(提升)function add(num1,num2){var sum = num1 + num2; //var声明的变量 添加到 最近的执行环境all = num1 + num2; //没有var声明的变量 添加到 全局执行环境}查询标识符(标识符解析)通过作用域链来查询3 垃圾收集JavaScript具有自动垃圾收集机制。对于哪些是无用变量的标记策略浏览器中的实现大致两种：标记清除 引用计数3.1 标记清除(常见)所有变量标记 ==&gt; 去掉 (环境中的变量+被环境中的变量引用的变量) 的标记 ==&gt; 垃圾收集器执行内存清除由浏览器决定垃圾收集的时间间隔3.2 引用计数(少见)记录每个值被引用的次数，当变成0时内存回收。3.3 性能问题垃圾收集的时间间隔很大程度决定了性能。有些浏览器可以通过调用接口来主动执行垃圾收集，不建议这样做。3.4 管理内存系统分配给Web浏览器的内存比桌面应用程序少很多，内存非常限制。优化内存方式 解除引用function createPerson(name){var localPerson = new Object();localPerson.name = name;return localPerson;}var globalPerson = createPerson(“Nicholas”); //隐式解除了内部localPerson的引用globalPerson = null; //显式解除了globalPerson的引用建议及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第三章（3）","slug":"《JavaScript高级程序设计》第三章（3）","date":"2017-01-26T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/01/27/《JavaScript高级程序设计》第三章（3）/","link":"","permalink":"http://blog.heavenbin.live/2017/01/27/《JavaScript高级程序设计》第三章（3）/","excerpt":"","text":"基本概念6 语句6.1 if语句12345//自动调用Boolean()转换函数将表达式的结果转换为一个布尔值if() ~~~~ else ~~~~ //不推荐if() &#123;~~~~&#125; else &#123;~~~~&#125; //推荐if() ~~~~ else if() ~~~~ else ~~~~ //不推荐if() &#123;~~~~&#125; else if() &#123;~~~~&#125; else &#123;~~~~&#125; //推荐6.2 do-while语句1do&#123;~~~~&#125;while() //至少会被执行一次6.3 while语句1while() &#123;~~~~&#125; //有可能一次都不会执行6.4 for语句12345//for语句只是在while语句的基础上加了一些参数。//while循环做不到的，for也做不到。for(;;) &#123;~~~~&#125; //无限循环for(;i&lt;10;) &#123;~~~~&#125; //相当于while语句for(let i=0;i&lt;10;i++) &#123;~~~~&#125; //常规使用6.5 for-in语句12//for-in语句用来枚举对象的属性。for(var propName in window)&#123; document.write(propName); &#125;6.6 label语句12345678//使用label语句可以在代码中添加标签，以便将来使用。一般与循环语句配合使用。start: for()&#123; for()&#123; continue start; &#125;&#125;// start是标签名，后面是对应的代码，可以由break或continue语句引用6.7 break和continue语句12345//精确地控制代码的执行。break //立即退出循环continue //立即退出循环后从循环的顶部继续执行(结合label语句可以跳出多个循环)for()&#123; ~~~~break;~~~~ &#125;for()&#123; ~~~~continue;~~~~ &#125;6.8 with语句12345678910//作用是将代码的作用域设置到一个特定的对象中，主要为了简化多次编写同一个对象的工作。var qs = location.search.substring(1);var hostName = location.hostname;with(location)&#123;var qs = search.substring(1);var hostName = hostname;&#125;//其实可以通过赋值来简写，不必用whit语句。//严格模式下不允许使用with语句，否则将视为语法错误。6.9 switch语句123456789101112//流程控制语句，一般在多个分支的时候考虑用。switch(i) &#123; case 25: alert(“25”); break; case 35: alert(“35”); break; default: alert(“other”);&#125;//i 可以是任何数据类型，每个case值可以是常量、变量、表达式，比较值时用的是全等操作符。7 函数1234567891011//声明function sayHi(name, message)&#123; alert(“hello” + name + “,” + message);&#125;//调用sayHi(“Nicholas”, “how are you today?”);//返回值return; //停止运行后将返回undefinedreturn name; //停止运行后将返回name7.1 理解参数12345678//上面name, message 这些命名的参数只是提供便利，其实可以不写。//可以传入N个参数，可以传入任何数据类型。arguments: (类数组)arguments[0] 第一个参数 name 两者的内存空间是独立的，但是保持同步arguments[1] 第二个参数 message 两者的内存空间是独立的，但是保持同步length 实参的个数arguments: undefined (没有参数)//严格模式将不能修改arguments的值。7.2 没有重载当定义了两个相同名字的函数时，改名字只属于后定义的函数。但是可以通过里面进行判断传入的参数个数来实现重载。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第三章（2）","slug":"《JavaScript高级程序设计》第三章（2）","date":"2017-01-19T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/01/20/《JavaScript高级程序设计》第三章（2）/","link":"","permalink":"http://blog.heavenbin.live/2017/01/20/《JavaScript高级程序设计》第三章（2）/","excerpt":"","text":"基本概念5 操作符5.1 一元操作符只能操作一个值的操作符++ – 、+ -(可用于转换数据类型)5.2 位操作符ECMAScript中所有数值都以IEEE-754 64位格式存储，位操作符将64位-32位-64位。有符号的整数 前31位表示整数的值 32位表示符号(0正数 1负数)0000 0000 0000 0000 0000 0000 0000 0001 ====&gt; 11000 0000 0000 0000 0000 0000 0000 0001 ====&gt; -1求负数的二进制码，例如-180000 0000 0000 0000 0000 0000 0001 0010 ====&gt; 18==反码==&gt; 1111 1111 1111 1111 1111 1111 1110 1101==加一==&gt;1111 1111 1111 1111 1111 1111 1110 1110 ====&gt; -18按或非~ (操作数的负值减1)var num1 = 25;var num2 = ~num1;0000 0000 0000 0000 0000 0000 0001 1001 ====&gt; 251111 1111 1111 1111 1111 1111 1110 0110 ====&gt; -26按位与&amp;var result = 25 &amp; 3;0000 0000 0000 0000 0000 0000 0001 1001 ====&gt; 250000 0000 0000 0000 0000 0000 0000 0011 ====&gt; 30000 0000 0000 0000 0000 0000 0000 0001 ====&gt; 1按位或|var result = 25 | 3;0000 0000 0000 0000 0000 0000 0001 1001 ====&gt; 250000 0000 0000 0000 0000 0000 0000 0011 ====&gt; 30000 0000 0000 0000 0000 0000 0001 1011 ====&gt;27左移&lt;&lt;var oldValue = 2;var newValue = oldValue &lt;&lt; 5;0000 0000 0000 0000 0000 0000 0000 0010 ====&gt; 20000 0000 0000 0000 0000 0000 0100 0000 ====&gt; 64有符号的右移&gt;&gt;前31位向右移动var oldValue = 64;var newValue = oldValue &gt;&gt; 5;0000 0000 0000 0000 0000 0000 0100 0000 ====&gt; 640000 0000 0000 0000 0000 0000 0000 0010 ====&gt; 2无符号的右移&gt;&gt;&gt;前32位向右移动，正数一样，负数则差别大。0000 0000 0000 0000 0000 0000 0100 0000 ====&gt; 640000 0000 0000 0000 0000 0000 0000 0010 ====&gt; 21111 1111 1111 1111 1111 1111 1100 0000 ====&gt; -640000 0111 1111 1111 1111 1111 1111 1110 ====&gt; 1342177265.3 布尔操作符逻辑非！逻辑与&amp;&amp; &emsp; 逻辑或|| (短路操作符：第一个操作数能出结果，第二个不会执行)5.4 乘性操作符乘法*除法/求模%5.5 加性操作符加法+减法-5.6 关系操作符小于&lt;大于&gt;小于等于&lt;=大于等于&gt;=5.7 相等操作符相等== 与 不相等!= &emsp; &emsp; 先转换再比较全等=== 与 不全等!== &emsp; &emsp; 仅比较而不转换5.8 条件操作符1var max = (num1 &gt; num2) ? num1 : num2; //简化写法，没有性能提升5.9 赋值操作符1= *= /= %= +== -== &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= //简化操作，没有性能提升5.10 逗号操作符12var num1=1, num2=2, num3=3;var num = (5,1,4,8,0); //num的值为0","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第三章（1）","slug":"《JavaScript高级程序设计》第三章（1）","date":"2017-01-14T16:00:00.000Z","updated":"2018-09-02T18:35:44.000Z","comments":true,"path":"2017/01/15/《JavaScript高级程序设计》第三章（1）/","link":"","permalink":"http://blog.heavenbin.live/2017/01/15/《JavaScript高级程序设计》第三章（1）/","excerpt":"","text":"基本概念1 语法1.1 区分大小写1.2 标识符第一个字符：字母、下划线、美元符号其它字符：可以是数字建议：用驼峰大小写myCar1.3 注释单行 //多行 /**/1.4 严格模式ECMAScript5引入严格模式(“use strict”;)，为JavaScript定义了一种不同的解析和执行模型。1.5 语句要用分号; &emsp; 一个语句也要用{}1234var sum = a + b; //推荐 var diff = a - b //不推荐if (test) &#123;alert(test);&#125; //推荐 if (test) alert(test); //不推荐2 关键字和保留字关键字：var if for …保留字：int long char …3 变量ECMAScript的变量是松散类型的，可以保存任何类型的数据。123456undefined //未初始化var message = “hi”; message = 100; //类型随便换function test()&#123; var a = “hi”; //局部变量，函数退出后销毁 b = “hi”; //全局变量，不推荐&#125;4 数据类型基本数据类型：Undefined、Null、Boolean、Number、String复杂数据类型：ObjectFunction函数在ECMAScript中是对象，不是一种数据类型。4.1 typeof操作符用于检测给定变量的数据类型4.2 Undefined类型只有一个值：undefined12//定义但未被赋值var message; alert(message); //“underfined”4.3 Null类型只有一个值：null123//空对象指针var car = null; alert(typeof car); // “object”alert(null == undefined); // true4.4 Boolean类型只有两个字面值：true false流程控制语句会自动执行相应boolean转换4.5 Number类型整数八进制 079 &emsp; 十进制 12 &emsp; 十六进制 0x1f进行算数计算都被转为十进制浮点数值(两倍整数空间)1234567891.1 0.1 .1 //有效不推荐1. 10.0 //ECMAScript会自动转换成整数保存 //ECMAScript会将点后面带有6个零以上的浮点数值转换为以e表示法表示的数值0.0000003 ====&gt; 3e-7//浮点数值的最高精度是17位小数//这是使用基于IEEE754数值的浮点计算的通病0.1 + 0.2 = 0.30000000000000004数值范围123456789//最小数值 Number.MIN_VALUE 5e-324//最大数值 Number.MAX_VALUE 1.7976931348623157e+308//负无穷 Number.NEGATIVE_INFINITY -Infinity //正无穷Number.POSITIVE_INFINITY Infinity isFinite() //在参数位于最小与最大数值之间时会返回trueNaN(Not a Number)123456//表示一个本来要返回数值的操作数未返回数值的情况alert(NaN == NaN); //falseisNaN() //确定参数是否“不是数值” ( 内部用到valueOf()、toString() )NaN “blue” //true 10 “10” true //false转换为数值非数值 ====&gt; 数值Number() 任何数据类型parseInt() parseFloat() 仅字符串4.6 String类型由零或多个16位Unicode字符组成的字符序列单引号 &emsp; 双引号 &emsp;&emsp; 没有区别字符字面量(转义序列)字符串的特点一旦创建值就不能改变，要改变首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。转换为字符串toString() 仅数值、布尔值、对象和字符串值String() 任何数据类型(多了null ===&gt; null, undefined ===&gt; undefined)4.7 Object类型对象：一组数据和功能的集合，可以通过执行new操作符后跟要创建的对象类型的名称来创建。在ECMAScript中Object是所有对象的基础(除了宿主对象，例如DOM,BOM)！1234567891011var o = new Object();//Object的每个实例都具有下列属性和方法：constructor //创建当前对象的函数hasOwnProperty(propertyName) //检查给定的属性在当前对象实例中是否存在isPrototypeOf(object) //检查传入的对象是否是当前对象的原型propertyIsEnumerable(propertyName) //检测给定的属性是否能够使用for-in语句来枚举toLocaleString() //返回对象的字符串表示(跟地区有关)toString() //返回对象的字符串表示valueOf() //返回对象的字符串、数值或布尔值表示","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第二章","slug":"《JavaScript高级程序设计》第二章","date":"2017-01-06T16:00:00.000Z","updated":"2018-09-29T08:32:19.000Z","comments":true,"path":"2017/01/07/《JavaScript高级程序设计》第二章/","link":"","permalink":"http://blog.heavenbin.live/2017/01/07/《JavaScript高级程序设计》第二章/","excerpt":"","text":"第二章 HTML中使用JavaScript1 script元素6个属性：async &emsp; 异步脚本，但脚本执行顺序打乱charset &emsp; 字符集defer &emsp; 延迟脚本，有些浏览器不支持language &emsp; 已经废弃src &emsp; 外部JS文件，可跨域type &emsp; MIME类型，默认text/javascriptscript元素 可用于攻击1.1 标签的位置位置放在中，这样不会延时。1.2 延迟脚本defer属性 &emsp; 只适用于外部脚本文件，且不同浏览器支持度不一样。最佳选择还是把延迟脚本放在页面底部。1.3 异步脚本async属性 &emsp; 只适用于外部脚本文件，且脚本执行顺序会被打乱。2 嵌入代码与外部文件最好的做法还是尽可能使用外部文件来包含JavaScript代码。优点：可维护性、可缓存、适应未来。3 文档模式混杂模式 &emsp; 默认标准模式 &emsp; HTML4.01严格型、XHTML1.0严格型、HTML5准标准模式 &emsp; HTML4.01过渡型、HTML4.01框架集型、XHTML1.0过渡型、XHTML1.0框架集型标准模式和准标准模式差别可以忽略不计。影响：主要影响CSS内容的呈现，某些情况的JS解释执行。4 noscript元素1&lt;noscript&gt;&lt;p&gt;浏览器不支持脚本，或者脚本被禁用时会显示这些内容&lt;/p&gt;&lt;/noscript&gt;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]},{"title":"《JavaScript高级程序设计》第一章","slug":"《JavaScript高级程序设计》第一章","date":"2016-12-26T16:00:00.000Z","updated":"2018-09-29T09:54:48.000Z","comments":true,"path":"2016/12/27/《JavaScript高级程序设计》第一章/","link":"","permalink":"http://blog.heavenbin.live/2016/12/27/《JavaScript高级程序设计》第一章/","excerpt":"","text":"JavaScript简介1 JavaScript简史Netscape公司的布兰登.艾奇 LiveScriptNetscape Navigator 的 JavaScript Internet Explorer 的 JScript欧洲计算机制造商协会(ECMA) ECMAScript2 JavaScript实现ECMAScript：由ECMA-262定义，提供核心语言功能文档对象模型(DOM)：提供访问和操作网页内容的方法和接口浏览器对象模型(BOM)：提供与浏览器交互的方法和接口2.1 ECMAScript宿主环境：Web浏览器、Node、Adobe Flash。大致内容：语法 类型 语句 关键字 保留字 操作符 对象最近版本：ECMAScript3.1(ECMA-262第5版) 2009-12-3支持度： Web浏览器对ECMAScript的兼容版本不一致。2.2 文档对象模型(DOM)DOM级别：DOM0级 Internet Explorer4.0和Netscape Navigator4.0最初支持的DHTMLDOM1级 DOM Core 和 DOM HTMLDOM2级 视图，事件，样式，遍历和范围DOM3级 加载和保存，验证，支持XML1.0规范其它DOM标准：SVG1.0、MathML1.0、SMIL。支持度：目前基本上是DOM2全部，DOM3部分。2.3 浏览器对象模型(BOM)支持度：已经正式纳入HTML5标准，尽管都实现了某些共同特性，但其他特性还是会因浏览器而异。3 JavaScript版本Netscape“继承人”Mozilla公司Mozilla(摩斯拉)开发团队的目标是构建与标准100%兼容的浏览器，而他们的努力也得到了回报。大多数浏览器在提及对JavaScript的支持情况时，一般都是看ECMAScript和DOM的支持度。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.heavenbin.live/categories/读书笔记/"}],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://blog.heavenbin.live/tags/JavaScript高级程序设计/"}]}]}