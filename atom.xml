<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.heavenbin.live/"/>
  <updated>2018-09-30T08:38:27.000Z</updated>
  <id>http://blog.heavenbin.live/</id>
  
  <author>
    <name>HeavenBin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多页面Webpack4脚手架</title>
    <link href="http://blog.heavenbin.live/2018/08/17/%E5%A4%9A%E9%A1%B5%E9%9D%A2Webpack%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>http://blog.heavenbin.live/2018/08/17/多页面Webpack脚手架/</id>
    <published>2018-08-16T16:00:00.000Z</published>
    <updated>2018-09-30T08:38:27.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a><strong>前言</strong>：</h2><blockquote><p>在开发中当遇到多页面项目时需要对应的自动化编译工具，所以针对多页面应用制作了一款webpack脚手架。供给大家互相学习，有什么疑问可以issues我。</p><ul><li>源码地址：<a href="https://github.com/HeavenBin/WebpackTemplate" target="_blank" rel="noopener">https://github.com/HeavenBin/WebpackTemplate</a></li></ul></blockquote><hr><h2 id="项目构成"><a href="#项目构成" class="headerlink" title="项目构成"></a>项目构成</h2><pre>├── build                        // webpack配置目录│   ├── utils.js                      // 工具文件│   ├── config.js                    // 配置文件│   ├── webpack.config.base.js   // 基础构建│   ├── webpack.config.dev.js    // 开发模式构建│   ├── webpack.config.prod.js   // 生产模式构建├── dist                              // 生产目录├── src                               // 开发目录├── .babelrc                         // babel配置├── .editorconfig                // editorconfig配置├── .eslintignore                // eslint排除的检测范围├── .eslintrc.js                 // eslint配置├── postcss.config.js            // postcss配置</pre><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>Webpack4：现代 JavaScript 应用程序的静态模块打包器 (自动化构建工具)</li><li>editorconfig：编辑器样式风格的统一配置 (统一代码风格工具)</li><li>eslint：JavaScript和JSX检查工具 (TS/ES代码语法检测)</li><li>babel：JavaScript 语法转换器 (TS/ES代码转换器)</li><li>postcss: 使用JavaScript转换CSS的工具 (CSS预处理平台)</li><li>支持各种CSS扩展语言的转化及压缩：css、less、sass、stylus</li><li>支持各种格式文件的预处理以及压缩：文字类、图片类、影音类</li><li>之后还会加入: 单元测试、端对端测试、…</li></ul><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><blockquote><p>需要NodeJS环境、git环境，<br>我所使用的版本：node v10.1.0 npm 6.3.0</p><ol><li>克隆库到本地<br>HTTPS方式： git clone <a href="https://github.com/HeavenBin/WebpackTemplate.git" target="_blank" rel="noopener">https://github.com/HeavenBin/WebpackTemplate.git</a><br>SSH方式：git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:HeavenBin/WebpackTemplate.git</li></ol></blockquote><ol start="2"><li><p>cd WebpackTemplate 进入项目目录</p></li><li><p>打开build/config.js文件根据自身要求进行自定义设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  projectPath: utils.resolve(<span class="string">'/'</span>),                                  <span class="comment">// 项目根目录</span></span><br><span class="line">  srcPath: utils.resolve(<span class="string">'/src/'</span>),                                  <span class="comment">// 源文件目录</span></span><br><span class="line">  node_modulesPath: utils.resolve(<span class="string">'/node_modules/'</span>),                <span class="comment">// node_modules目录</span></span><br><span class="line"></span><br><span class="line">  htmlPath: utils.resolve(<span class="string">'/src/'</span>),                                 <span class="comment">// HTML目录</span></span><br><span class="line">  jsPath: utils.resolve(<span class="string">'/src/main/'</span>),                              <span class="comment">// JS目录</span></span><br><span class="line"></span><br><span class="line">  ignoreJs: [<span class="string">'test'</span>],                                               <span class="comment">// 没有入口js文件的html名</span></span><br><span class="line">  assetsSubDirectory: utils.resolve(<span class="string">'/src/static/'</span>),                <span class="comment">// 静态资源目录(不处理的第三方代码)</span></span><br><span class="line"></span><br><span class="line">  dev: &#123;</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    port: <span class="string">'3002'</span>,</span><br><span class="line"></span><br><span class="line">    useEslint: <span class="literal">false</span>,                                                <span class="comment">// 是否使用ESlint</span></span><br><span class="line">    showEslintErrorsInOverlay: <span class="literal">true</span>,                                 <span class="comment">// 设置为true，ESlint-loader将始终返回警告。</span></span><br><span class="line"></span><br><span class="line">    devSourceMap: <span class="literal">false</span>,                                             <span class="comment">// 是否开启SourceMap</span></span><br><span class="line">    devtool: <span class="string">'eval-source-map'</span>,</span><br><span class="line"></span><br><span class="line">    assetsPublicPath: <span class="string">'/'</span>,                                           <span class="comment">// 相对于服务器根目录的路径，用于加载资源。</span></span><br><span class="line"></span><br><span class="line">    proxyTable: &#123;                                                    <span class="comment">// proxy代理</span></span><br><span class="line">      <span class="string">'/api'</span>: <span class="string">'http://localhost:3000'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  build: &#123;</span><br><span class="line">    prodSourceMap: <span class="literal">false</span>,                                             <span class="comment">// 是否开启SourcMap</span></span><br><span class="line">    devtool: <span class="string">'source-map'</span>,</span><br><span class="line"></span><br><span class="line">    assetsRoot: path.resolve(__dirname, <span class="string">'../dist'</span>),                  <span class="comment">// 构建根目录</span></span><br><span class="line">    assetsPublicPath: <span class="string">'/'</span>                                            <span class="comment">// 相对于服务器根目录的路径，用于加载构建好的资源。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>npm run build 构建dist生产目录</p></li><li><p>npm run dev 构建热更新服务</p></li><li><p>开始进行开发</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong
      
    
    </summary>
    
      <category term="Webpack" scheme="http://blog.heavenbin.live/categories/Webpack/"/>
    
    
      <category term="多页面" scheme="http://blog.heavenbin.live/tags/%E5%A4%9A%E9%A1%B5%E9%9D%A2/"/>
    
      <category term="脚手架" scheme="http://blog.heavenbin.live/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用纯原生JS造轮子(不依赖任何框架)</title>
    <link href="http://blog.heavenbin.live/2018/05/15/%E4%BD%BF%E7%94%A8%E7%BA%AF%E5%8E%9F%E7%94%9FJS%E9%80%A0%E8%BD%AE%E5%AD%90(%E4%B8%8D%E4%BE%9D%E8%B5%96%E4%BB%BB%E4%BD%95%E6%A1%86%E6%9E%B6)/"/>
    <id>http://blog.heavenbin.live/2018/05/15/使用纯原生JS造轮子(不依赖任何框架)/</id>
    <published>2018-05-14T16:00:00.000Z</published>
    <updated>2018-09-03T09:00:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a><strong>前言</strong>：</h2><blockquote><p>从原生JS入手,构造常用的工具库以及常见的场景插件。供给大家互相学习，有什么疑问可以issues我。</p><ul><li>源码地址：<a href="https://github.com/HeavenBin/JsWheels" target="_blank" rel="noopener">https://github.com/HeavenBin/JsWheels</a></li></ul></blockquote><hr><p>使用原生JS构造常用的工具库以及常见的场景插件,俗称造轮子!<br>不用任何框架、预编译，用最笨的办法造轮子<br>使用最新 JS 语法编写</p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p><a href="https://heavenbin.github.io/JsWheels/" target="_blank" rel="noopener">https://heavenbin.github.io/JsWheels/</a></p><h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><ul><li>部分BOM</li><li>部分DOM</li><li>Tab切换栏</li><li>分页插件</li></ul><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><blockquote><p>git clone <a href="https://github.com/HeavenBin/JsWheels.git" target="_blank" rel="noopener">https://github.com/HeavenBin/JsWheels.git</a><br>cd JsWheels<br>浏览器 打开 index.html</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.heavenbin.live/categories/JavaScript/"/>
    
    
      <category term="原生造轮子" scheme="http://blog.heavenbin.live/tags/%E5%8E%9F%E7%94%9F%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>基于vue2+vuex+vue-router+sass+webpack的网易云音乐</title>
    <link href="http://blog.heavenbin.live/2018/03/17/%E5%9F%BA%E4%BA%8Evue2+vuex+vue-router+sass+webpack%E7%9A%84%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"/>
    <id>http://blog.heavenbin.live/2018/03/17/基于vue2+vuex+vue-router+sass+webpack的网易云音乐/</id>
    <published>2018-03-16T16:00:00.000Z</published>
    <updated>2018-09-03T08:56:53.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a><strong>前言</strong>：</h2><blockquote><p>这段时间写的一个项目，供给大家互相学习，有什么疑问可以issues我。</p><ul><li>源码地址：<a href="https://github.com/HeavenBin/VueMusic" target="_blank" rel="noopener">https://github.com/HeavenBin/VueMusic</a></li></ul></blockquote><hr><h2 id="项目构成"><a href="#项目构成" class="headerlink" title="项目构成"></a>项目构成</h2><pre>├── build                  // webpack配置文件├── config                     // 不同环境的打包配置├── dist                        // 生产目录├── index.html               // 入口html文件├── package.json               // 项目配置文件├── static                        // 放置静态资源├── src                         // 开发目录│   ├── pages                  // 页面│   ├── components              // 组件│   ├── config                  // 基本配置│   ├── images                  // 公共图片│   ├── plugins                // 引用插件│   ├── router                  // 路由配置│   ├── service              // 数据交互│   ├── store                  // vuex状态管理│   ├── style                  // 公共样式│   ├── App.vue               // 页面入口文件│   └── main.js              // 程序入口文件</pre><hr><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><pre>Vue2：           采用现代渐进式框架Vue2的版本Vuex：           管理公共组件状态量vue-router：     管理单页面应用路由自定义ajax：      基于xmlhttprequest对象以及新兴Fetch对象结合封装的http请求CSS3：           CSS3动画及样式。Sass：           CSS预处理语言。Webpack：        自动化构建工具，主要配置vue-cli脚手架提供。ES6：            采用ES6语法。SVG：            基于可扩展标记语言的可缩放矢量图形。接口来源(感谢Binaryify不断更新的网易云音乐接口)</pre><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong
      
    
    </summary>
    
      <category term="Vue" scheme="http://blog.heavenbin.live/categories/Vue/"/>
    
    
      <category term="音乐播放器" scheme="http://blog.heavenbin.live/tags/%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript模块化的演变</title>
    <link href="http://blog.heavenbin.live/2018/01/18/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E6%BC%94%E5%8F%98/"/>
    <id>http://blog.heavenbin.live/2018/01/18/JavaScript模块化的演变/</id>
    <published>2018-01-17T17:26:25.000Z</published>
    <updated>2018-09-02T18:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h2 id="函数封装"><a href="#函数封装" class="headerlink" title="函数封装"></a>函数封装</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>缺点<br>&emsp;污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。</li></ul><hr><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = &#123;</span><br><span class="line">  var1: <span class="number">1</span>,</span><br><span class="line">  var2: <span class="number">2</span>,</span><br><span class="line">  fn1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  fn2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>优点<br>&emsp;避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系。</p></li><li><p>缺点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myModele.var1 = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;这样就会产生意外的安全问题</p><hr><h2 id="立即执行函数-模块化的基础"><a href="#立即执行函数-模块化的基础" class="headerlink" title="立即执行函数(模块化的基础)"></a>立即执行函数(模块化的基础)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> var1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> var2 = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    fn1: fn1,</span><br><span class="line">    fn2: fn2</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>优点<br>&emsp;在模块外部无法修改我们没有暴露出来的变量、函数。</li></ul><hr><h2 id="CommonJS规范（NodeJS）"><a href="#CommonJS规范（NodeJS）" class="headerlink" title="CommonJS规范（NodeJS）"></a>CommonJS规范（NodeJS）</h2><p>&emsp;&emsp;由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。</p><ul><li><p>定义模块<br>&emsp;根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。</p></li><li><p>模块输出<br>&emsp;模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象。</p></li><li><p>加载模块<br>&emsp;加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模块定义 myModel.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Byron'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFullName</span>(<span class="params">firstName</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(firstName + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  printName: printName,</span><br><span class="line">  printFullName: printFullName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载模块</span></span><br><span class="line"><span class="keyword">var</span> nameModule = <span class="built_in">require</span>(<span class="string">'./myModel.js'</span>);</span><br><span class="line">nameModule.printName();</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;不同的实现对require时的路径有不同要求，一般情况可以省略js拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块）</p><hr><h2 id="尴尬的浏览器"><a href="#尴尬的浏览器" class="headerlink" title="尴尬的浏览器"></a>尴尬的浏览器</h2><p>&emsp;&emsp;仔细看上面的代码，会发现require是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。<br>&emsp;&emsp;浏览器端，加载JavaScript最佳、最容易的方式是在document中插入script 标签。但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载。</p><ul><li>解决思路：</li></ul><ol><li>开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。 这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。</li><li>用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生了分歧：AMD CMD</li></ol><hr><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>&emsp;&emsp;Asynchromous Module Definition - 异步模块定义<br>&emsp;&emsp;由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数RequireJS。<br>&emsp;&emsp;AMD是RequireJS在推广过程中对模块定义的规范化产出，AMD是异步加载模块，推崇依赖前置。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'module1'</span>, [<span class="string">'jquery'</span>], ($) =&gt; &#123;</span><br><span class="line"><span class="comment">//do something...</span></span><br><span class="line">&#125;);</span><br><span class="line">代码中依赖被前置，当定义模块（module1）时，就会加载依赖（jquery）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义模块 myModule.js</span></span><br><span class="line">define([<span class="string">'dependency'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Byron'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    printName: printName</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'myModule'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">my</span>)</span>&#123;</span><br><span class="line">　 my.printName();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><ul><li>解决的问题</li></ul><ol><li>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。</li><li>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长。require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应。它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</li></ol><hr><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>&emsp;&emsp;Common Module Definition - 公共模块定义）（国内发展出来的）<br>&emsp;&emsp;CMD是SeaJS在推广过程中对模块定义的规范化产出，对于模块的依赖，CMD是延迟执行，推崇依赖就近。<br>&emsp;&emsp;SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。</p><ul><li>推崇</li></ul><ol><li>一个文件一个模块，所以经常就用文件名作为模块id。</li><li>CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function">(<span class="params"><span class="built_in">require</span>, exports, <span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">fun1: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line"><span class="keyword">return</span> $(<span class="string">'#test'</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>如上代码，只有当真正执行到fun1方法时，才回去执行jquery。<br>同时CMD也是延自CommonJS Modules/2.0规范<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块 myModule.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery.js'</span>)</span><br><span class="line">$(<span class="string">'div'</span>).addClass(<span class="string">'active'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">'myModule.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">my</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><hr><h2 id="AMD-和-CMD"><a href="#AMD-和-CMD" class="headerlink" title="AMD 和 CMD"></a>AMD 和 CMD</h2><p>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块<br>CMD推崇就近依赖，只有在用到某个模块的时候再去require<br>AMD用户体验好，因为没有延迟，依赖模块提前执行了。<br>CMD性能好，因为只有用户需要的时候才执行。</p><hr><h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><p>&emsp;&emsp;Universal Module Definition - 通用模块定义<br>&emsp;&emsp;UMD是AMD和CommonJS的一个糅合。<br>&emsp;&emsp;AMD是浏览器优先，异步加载；CommonJS是服务器优先，同步加载。</p><p>&emsp;&emsp;既然要通用，怎么办呢？那就先判断是否支持node.js的模块，存在就使用node.js；再判断是否支持AMD（define是否存在），存在则使用AMD的方式加载。这就是所谓的UMD。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">(<span class="params">root, factory</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line"><span class="comment">//AMD</span></span><br><span class="line">define([<span class="string">'jquery'</span>], factory);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123;</span><br><span class="line"><span class="comment">//CommonJS</span></span><br><span class="line"><span class="keyword">var</span> $ = requie(<span class="string">'jquery'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = factory($);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//都不是，浏览器全局定义</span></span><br><span class="line">root.testModule = factory(root.jQuery);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(<span class="keyword">this</span>, ($) =&gt; &#123;</span><br><span class="line"><span class="comment">//do something... 这里是真正的函数体</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><ul><li>缺点<br>&emsp;CommonJS 和 AMD 模块，都只能在运行时确定模块的依赖关系，以及输入和输出的变量。</li></ul><hr><h2 id="ES6-import"><a href="#ES6-import" class="headerlink" title="ES6(import)"></a>ES6(import)</h2><ul><li>优点<br>&emsp;ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;函数封装&quot;&gt;&lt;a href=&quot;#函数封装&quot; class=&quot;headerlink&quot; title=&quot;函数封装&quot;&gt;&lt;/a&gt;函数封装&lt;/h2&gt;&lt;figur
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.heavenbin.live/categories/JavaScript/"/>
    
    
      <category term="模块化" scheme="http://blog.heavenbin.live/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端布局总结-盒子布局</title>
    <link href="http://blog.heavenbin.live/2017/11/26/%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93-%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80/"/>
    <id>http://blog.heavenbin.live/2017/11/26/前端布局总结-盒子布局/</id>
    <published>2017-11-25T16:00:00.000Z</published>
    <updated>2018-09-02T18:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h1 id="盒子布局"><a href="#盒子布局" class="headerlink" title="盒子布局"></a>盒子布局</h1><h2 id="高度、宽度的选择与范围"><a href="#高度、宽度的选择与范围" class="headerlink" title="高度、宽度的选择与范围"></a>高度、宽度的选择与范围</h2><ul><li><p><strong>宽度</strong></p><blockquote><p>使用rem的方式则使用 rem / % 都一样，哪个方便用哪个</p></blockquote></li><li><p><strong>高度</strong></p></li></ul><ol><li>撑出高度(不设置高度)</li><li>必须有高度 (外层：外层可以多层，且全部用% 内层：开始用rem之后)</li></ol><blockquote><p><strong>%</strong> （若有比例范围，则容易变形）<br>外层 需要进行设置 —-一般全屏页面使用，方便比例<br>内层 看同层盒子高度是否成比例 —-与rem没什么两样,方便比例</p></blockquote><blockquote><p><strong>rem</strong> （若有比例范围，则只能固定一个比例）<br>外层 没有外层<br>内层 最外层的固定高度 &lt; 适配手机的最小高度分辨率！！！！<br>—-全屏 640x1136 微信+手机自带 640x1011 浏览器</p></blockquote><hr><h2 id="上下左右居中"><a href="#上下左右居中" class="headerlink" title="上下左右居中"></a>上下左右居中</h2><ul><li><p><strong>上下左右全包</strong></p><pre>方法一：flex                                 ----未知宽度display: flex;justify-content: center;align-items: center;方法二：定位width: 100px; height: 50px;position: absolute;top: 50%; left: 50%;margin-top: -25px; margin-left: -50px;    ----固定宽度transform: translate(-50%, -50%);         ----未知宽度</pre></li><li><p><strong>左右居中</strong></p><pre>方法一：calc()margin-left: calc((100% - width)/2);       ----固定宽度方法二：marginmargin-left: auto; margin-right: auto;     ----未知宽度方法三：行内元素display: inline-block;text-align: center;  ----行内居中方法四：flex                                   ----未知宽度方法五：定位width: 100px; height: 50px;position: absolute;left: 50%;margin-left: -50px;                           ----固定宽度transform: translateX(-50%);                  ----未知宽度 </pre></li><li><p><strong>上下居中</strong></p><pre>方法一：calc()margin-top: calc((100% - height)/2);        ----固定宽度方法二：行内元素display: inline-block; height: 200px; line-height: 200px;  ----行内居中方法三：？vertical-align: middle;                      ----？方法四：flex                                   ----未知宽度方法五：定位width: 100px; height: 50px;position: absolute;top: 50%;margin-top: -25px;                            ----固定宽度transform: translateY(-50%);                 ----未知宽度</pre></li></ul><hr><h2 id="布局方式及选择"><a href="#布局方式及选择" class="headerlink" title="布局方式及选择"></a>布局方式及选择</h2><h4 id="盒子内外边距-单个盒子"><a href="#盒子内外边距-单个盒子" class="headerlink" title="盒子内外边距 (单个盒子)"></a>盒子内外边距 (单个盒子)</h4><ul><li><strong>稳定度： 宽高&gt;padding&gt;margin</strong></li></ul><hr><h4 id="各种居中-单个盒子"><a href="#各种居中-单个盒子" class="headerlink" title="各种居中 (单个盒子)"></a>各种居中 (单个盒子)</h4><hr><h4 id="浮动流布局-单个盒子"><a href="#浮动流布局-单个盒子" class="headerlink" title="浮动流布局 (单个盒子)"></a>浮动流布局 (单个盒子)</h4><ul><li><strong>float &emsp; left right both</strong></li></ul><hr><h4 id="定位流布局-单个盒子-盒子外"><a href="#定位流布局-单个盒子-盒子外" class="headerlink" title="定位流布局 (单个盒子 盒子外)"></a>定位流布局 (单个盒子 盒子外)</h4><ul><li><strong>position</strong></li></ul><hr><h4 id="普通流布局-多个盒子"><a href="#普通流布局-多个盒子" class="headerlink" title="普通流布局 (多个盒子)"></a>普通流布局 (多个盒子)</h4><ul><li><strong>从左到右，上到下，底边对齐，空白折叠，% + rem</strong></li><li><strong>display &emsp; inline block inline-block</strong></li></ul><hr><h4 id="Flex布局-多个盒子"><a href="#Flex布局-多个盒子" class="headerlink" title="Flex布局 (多个盒子)"></a>Flex布局 (多个盒子)</h4><ul><li><strong>display: flex;</strong><pre>九点筛子 + 项目之间的间隔比项目与边框的间隔大一倍space-around实际功能：1.普通流    ====    display     2.浮动      ====    float3.固定比例  ====    纵向%     横向  %+left4.自适应    ====    % + rem + calc()5.space-around   ====   感觉没啥用</pre></li></ul><p>盒子位置</p><blockquote><p>横向 首(间隔？)尾(间隔？)中(间隔？)两端(间隔？)四周(盒子间隔是边界间隔2倍)<br>纵向 首 尾 中 文字基线 默认全高</p></blockquote><hr><h4 id="Grid布局-多个盒子"><a href="#Grid布局-多个盒子" class="headerlink" title="Grid布局 (多个盒子)"></a>Grid布局 (多个盒子)</h4><ul><li><strong>Flex 与 Grid</strong><blockquote><p>Grid 定义两个维度， 更适合大模块的排布布局。<br>Flex 定义一个维度， 更适合内部内容布局。<br>在做一些布局时，可以同时使用 Grid 和 Flex。<br>如 做类似瀑布流的卡片。卡片的布局用 Grid，卡片内部的布局 Flex。</p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;盒子布局&quot;&gt;&lt;a href=&quot;#盒子布局&quot; class=&quot;headerlink&quot; title=&quot;盒子布局&quot;&gt;&lt;/a&gt;盒子布局&lt;/h1&gt;&lt;h2 id
      
    
    </summary>
    
      <category term="布局" scheme="http://blog.heavenbin.live/categories/%E5%B8%83%E5%B1%80/"/>
    
    
      <category term="盒子" scheme="http://blog.heavenbin.live/tags/%E7%9B%92%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>前端布局总结-页面布局</title>
    <link href="http://blog.heavenbin.live/2017/11/07/%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
    <id>http://blog.heavenbin.live/2017/11/07/前端布局总结-页面布局/</id>
    <published>2017-11-06T16:00:00.000Z</published>
    <updated>2018-09-02T18:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h1 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h1><h2 id="适配设备的屏幕比例范围"><a href="#适配设备的屏幕比例范围" class="headerlink" title="适配设备的屏幕比例范围"></a>适配设备的屏幕比例范围</h2><ul><li><p><strong>三星安卓</strong></p><pre>1.777777778 (640x360)                                   ----全屏1.575 (567x360)                                          ----微信+手机自带1.530555556 1.43888889 原生 (511x360) UC (518x360)    ----手机浏览器</pre></li><li><p><strong>iphone6</strong></p><pre>1.778666666667 (667x375) 1.608 (603x375) 1.490666667 (559x375)</pre></li><li><p><strong>iphone5</strong></p><pre>1.775 (568X320) 1.575 (504x320) 1.4375 (460x320)</pre></li></ul><hr><h2 id="全屏页面布局"><a href="#全屏页面布局" class="headerlink" title="全屏页面布局"></a>全屏页面布局</h2><ul><li><strong>原理 height:100%</strong><br><strong>方式一</strong><blockquote><p>html,body,div,…{height: 100%;}</p></blockquote></li></ul><p><strong>方式二</strong></p><blockquote><p>固定高宽为clientHeight clientWidth<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="built_in">document</span>.getElementById(<span class="string">'id'</span>);</span><br><span class="line">id.style.width = <span class="built_in">document</span>.documentElement.clientWidth +<span class="string">'px'</span>;</span><br><span class="line">id.style.height = <span class="built_in">document</span>.documentElement.clientHeight + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure><p></p></blockquote><p><strong>方式三</strong></p><blockquote><p>给父容器设置位置信息，让其得到高度信息。<br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">right</span>:<span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>:<span class="number">0px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;页面布局&quot;&gt;&lt;a href=&quot;#页面布局&quot; class=&quot;headerlink&quot; title=&quot;页面布局&quot;&gt;&lt;/a&gt;页面布局&lt;/h1&gt;&lt;h2 id
      
    
    </summary>
    
      <category term="布局" scheme="http://blog.heavenbin.live/categories/%E5%B8%83%E5%B1%80/"/>
    
    
      <category term="页面" scheme="http://blog.heavenbin.live/tags/%E9%A1%B5%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>前端布局总结-终端布局</title>
    <link href="http://blog.heavenbin.live/2017/10/23/%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93-%E7%BB%88%E7%AB%AF%E5%B8%83%E5%B1%80/"/>
    <id>http://blog.heavenbin.live/2017/10/23/前端布局总结-终端布局/</id>
    <published>2017-10-22T16:00:00.000Z</published>
    <updated>2018-09-30T08:34:07.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h1 id="终端布局"><a href="#终端布局" class="headerlink" title="终端布局"></a>终端布局</h1><h2 id="定宽布局-PC端"><a href="#定宽布局-PC端" class="headerlink" title="定宽布局(PC端)"></a>定宽布局(PC端)</h2><ul><li><strong>高宽固定</strong></li></ul><hr><h2 id="流式布局-移动端"><a href="#流式布局-移动端" class="headerlink" title="流式布局(移动端)"></a>流式布局(移动端)</h2><ul><li><strong>width:100% 宽响应，高固定，会变形</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div/body&#123;                     ----需要设置最大最小宽度限制，以免变形严重</span><br><span class="line">  <span class="selector-tag">min-width</span>: 300<span class="selector-tag">px</span>;</span><br><span class="line">  <span class="selector-tag">max-width</span>: 640<span class="selector-tag">px</span>;</span><br><span class="line">  <span class="selector-tag">margin</span>: 0 <span class="selector-tag">auto</span>;</span><br><span class="line">  <span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="rem布局-移动端"><a href="#rem布局-移动端" class="headerlink" title="rem布局(移动端)"></a>rem布局(移动端)</h2><ul><li><strong>高宽响应，比例不变，不会变形 (rem&gt;=12px)</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"html"</span>)[<span class="number">0</span>] === <span class="built_in">document</span>.documentElement); <span class="comment">//ture</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置rem (html的font-size) </span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">win,doc</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> recalc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> docEL = doc.documentElement;</span><br><span class="line"><span class="keyword">if</span> (!docEL.clientWidth) <span class="keyword">return</span>;</span><br><span class="line">docEL.style.fontSize = docEL.clientWidth / <span class="number">7.5</span> + <span class="string">'px'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//窗口改变事件(包括横竖屏切换orientationchange)</span></span><br><span class="line">win.addEventListener(<span class="string">'resize'</span>, recalc, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//DOM树构建完成事件</span></span><br><span class="line">doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, recalc, <span class="literal">false</span>);</span><br><span class="line">&#125;)(<span class="built_in">window</span>,<span class="built_in">document</span>)</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="响应式布局-移动端-PC端"><a href="#响应式布局-移动端-PC端" class="headerlink" title="响应式布局(移动端+PC端)"></a>响应式布局(移动端+PC端)</h2><ul><li><strong>根据屏幕宽度 写多套样式 bootstrap 媒体查询</strong></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;终端布局&quot;&gt;&lt;a href=&quot;#终端布局&quot; class=&quot;headerlink&quot; title=&quot;终端布局&quot;&gt;&lt;/a&gt;终端布局&lt;/h1&gt;&lt;h2 id
      
    
    </summary>
    
      <category term="布局" scheme="http://blog.heavenbin.live/categories/%E5%B8%83%E5%B1%80/"/>
    
    
      <category term="终端" scheme="http://blog.heavenbin.live/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Markdown速学教程</title>
    <link href="http://blog.heavenbin.live/2017/09/17/Markdown%E9%80%9F%E5%AD%A6%E6%95%99%E7%A8%8B/"/>
    <id>http://blog.heavenbin.live/2017/09/17/Markdown速学教程/</id>
    <published>2017-09-16T16:00:00.000Z</published>
    <updated>2018-09-02T18:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a><strong>前言</strong>：</h2><blockquote><p>这是一个速学Markdown教程，供给大家互相学习，有什么疑问可以issues我。</p><ul><li>源码地址：<a href="https://github.com/HeavenBin/MarkdownCourse" target="_blank" rel="noopener">https://github.com/HeavenBin/MarkdownCourse</a></li></ul></blockquote><hr><p><a name="1">顶部</a></p><h3 id="分级标题-‘-’"><a href="#分级标题-‘-’" class="headerlink" title="分级标题(‘#’)"></a>分级标题(‘#’)</h3><p>#+空格+一级标题</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>##+空格+二级标题</p><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>###+空格+三级标题</p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>####+空格+四级标题</p><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p>#####+空格+五级标题</p><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><p>######+空格+六级标题</p><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h3 id="空格-‘-‘"><a href="#空格-‘-‘" class="headerlink" title="空格(‘ ‘)"></a>空格(‘ ‘)</h3><p>1空格 = N空格/1换行 建议：1空格<br>N空格 =<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>标签</span><br><span class="line">&amp;ensp; 半方大的空白</span><br><span class="line">&amp;emsp; 全方大的空白</span><br><span class="line">&amp;nbsp; 不断行的空白格</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="换行-‘-‘-’回车’"><a href="#换行-‘-‘-’回车’" class="headerlink" title="换行(‘ ‘+’回车’)"></a>换行(‘ ‘+’回车’)</h3><p>1换行 = 2空格+1换行 建议：2空格+1换行<br>2换行 = 2换行 建议：2换行<br>N换行 =</p><hr><h3 id="强调"><a href="#强调" class="headerlink" title="强调(*_~)"></a>强调(*_~)</h3><p>*斜体<em> 或者 _斜体_ </em>斜体*，_斜体_</p><p>**粗体<strong> 或者 __粗体__ </strong>粗体**，<strong>粗体</strong></p><p>***加粗斜体<strong><em> </em></strong>加粗斜体***</p><p>~~删除线~~<br><del>删除线</del></p><hr><h3 id="区块引用-gt"><a href="#区块引用-gt" class="headerlink" title="区块引用(&gt;)"></a>区块引用(&gt;)</h3><blockquote><p>一一一一一一一一一一<br>二二二二二二二二二二<br>三三三三三三三三三三</p></blockquote><blockquote><p>四四四四四四四四四四<br>五五五五五五五五五五</p><blockquote><p>六六六六六六六六六六<br>七七七七七七七七七七<br>八八八八八八八八八八</p><blockquote><p>九九九九九九九九九九<br>十十十十十十十十十十</p></blockquote></blockquote></blockquote><hr><h3 id="代码区块-tab"><a href="#代码区块-tab" class="headerlink" title="代码区块(tab)"></a>代码区块(tab)</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"Hello, Markdown."</span>);</span><br><span class="line">&#125;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表(- + *)"></a>无序列表(- + *)</h3><ul><li>第一项</li><li>第二项</li></ul><ul><li>第一项</li><li>第二项</li></ul><ul><li>第一项</li><li>第二项</li></ul><hr><h3 id="有序列表-‘1-‘"><a href="#有序列表-‘1-‘" class="headerlink" title="有序列表(‘1. ‘)"></a>有序列表(‘1. ‘)</h3><ol><li>第一项</li><li>第二项</li></ol><hr><h3 id="表格-‘-‘"><a href="#表格-‘-‘" class="headerlink" title="表格(‘|-‘)"></a>表格(‘|-‘)</h3><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr></tbody></table><hr><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><hr><hr><hr><p>*** — ___</p><hr><h3 id="文字连接-‘-‘"><a href="#文字连接-‘-‘" class="headerlink" title="文字连接(‘[]()‘)"></a>文字连接(‘[]()‘)</h3><p>欢迎来到<a href="http://baidu.com" target="_blank" rel="noopener">baidu-停留没提示</a><br>欢迎来到<a href="http://baidu.com" title="baidu" target="_blank" rel="noopener">baidu-停留有提示</a></p><hr><h3 id="图片链接-‘-‘"><a href="#图片链接-‘-‘" class="headerlink" title="图片链接(‘![]()‘)"></a>图片链接(‘![]()‘)</h3><p><img src="http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg" alt="美丽花儿" title="美丽花儿"></p><hr><h3 id="自动链接-‘-lt-gt-’"><a href="#自动链接-‘-lt-gt-’" class="headerlink" title="自动链接(‘&lt;&gt;’)"></a>自动链接(‘&lt;&gt;’)</h3><p><a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a></p><hr><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p><a href="#1">回到顶部</a></p><hr><h3 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h3><p>在段落中填写 [TOC] 以显示全文内容的目录结构。</p><hr><h3 id="反转义作用"><a href="#反转义作用" class="headerlink" title="反转义作用(/)"></a>反转义作用(/)</h3><p>![图片名称](图片地址)<br>>&gt;反转义作用<br>***<br>- 变成普通符号</p><hr><h3 id="标记作用"><a href="#标记作用" class="headerlink" title="标记作用 ()"></a>标记作用 (<code></code>)</h3><p><code>ctrl+a</code></p><hr><h3 id="Fork或借鉴请注明出处-HeavenBin"><a href="#Fork或借鉴请注明出处-HeavenBin" class="headerlink" title="Fork或借鉴请注明出处 @ HeavenBin"></a>Fork或借鉴请注明出处 <a href="https://github.com/HeavenBin/MarkdownCourse" target="_blank" rel="noopener">@ HeavenBin</a></h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong
      
    
    </summary>
    
      <category term="Markdown" scheme="http://blog.heavenbin.live/categories/Markdown/"/>
    
    
      <category term="教程" scheme="http://blog.heavenbin.live/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CSS选择器-性能的探究及提升</title>
    <link href="http://blog.heavenbin.live/2017/08/13/CSS%E9%80%89%E6%8B%A9%E5%99%A8-%E6%80%A7%E8%83%BD%E7%9A%84%E6%8E%A2%E7%A9%B6%E5%8F%8A%E6%8F%90%E5%8D%87/"/>
    <id>http://blog.heavenbin.live/2017/08/13/CSS选择器-性能的探究及提升/</id>
    <published>2017-08-12T16:00:00.000Z</published>
    <updated>2018-09-02T18:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a><strong>前言</strong>：</h2><blockquote><p>在工作中编写CSS样式表时随着选择器层数的增加总会看到选择器又丑又长的情况，利用工作之余研究从其命名再到如何提高其性能。本博客将以“通俗易懂”、“简洁”的方式来探究CSS选择器的性能，以及叙述总结如何提升CSS选择器的性能。</p></blockquote><hr><h2 id="一-CSS选择器性能是如何消耗的？"><a href="#一-CSS选择器性能是如何消耗的？" class="headerlink" title="一. CSS选择器性能是如何消耗的？"></a>一. CSS选择器性能是如何消耗的？</h2><ul><li><p>工作原理：浏览器利用CSS选择器来匹配文档元素。</p></li><li><p>工作流程：例如 #hd .nav &gt; a { padding-left: 15px }</p><blockquote><p>1.在文档所有元素中寻找所有的 a 标签。<br>2.在1的结果中寻找其父元素的类名为“.nav”的元素。<br>3.在2的结果中寻找其父辈元素的ID为“hd”的元素。<br>4.在3的结果中增加样式。</p></blockquote></li></ul><hr><h2 id="二-分析怎么提升CSS选择器的性能？"><a href="#二-分析怎么提升CSS选择器的性能？" class="headerlink" title="二. 分析怎么提升CSS选择器的性能？"></a>二. 分析怎么提升CSS选择器的性能？</h2><p>在工作流程中可以看出有两个方面可以提升性能：寻找的效率和寻找的次数</p><blockquote><p>效率：选择器的搜索个数，个数越少性能越好。<br>次数：选择器的层数，层数越少性能越好。</p></blockquote><hr><h2 id="三-提升CSS选择器性能的方式"><a href="#三-提升CSS选择器性能的方式" class="headerlink" title="三. 提升CSS选择器性能的方式"></a>三. 提升CSS选择器性能的方式</h2><ul><li><p>方式一（减少搜索个数）：选择效率高的选择器，参考如下建议多用类选择器少用标签选择器。</p><pre>CSS选择器搜索个数从少到多的排序：　　id选择器（#myid）　　类选择器（.myclassname）　　标签选择器（div,h1,p）　　相邻选择器（h1+p）　　子选择器（ul > li）　　后代选择器（li a）　　通配符选择器（*）　　属性选择器（a[rel="external"]）　　伪类选择器（a:hover, li:nth-child）</pre></li><li><p>方式二（减少层数）：使用BEM（block_element-modifier）的命名方式。</p><pre>BEM：块（block）、元素（element）、修饰符（modifier）例如：　　.hd{}　　.hd_nav{}　　.hd_nav_a{}　　.hd_nav_a-link{}　　.hd_nav_a-visited{}</pre></li><li><p>方式三（减少层数）：使用面向属性的命名方式。</p><pre>面向属性：以“样式属性的功能”来给选择器命名。例如：　　.l{ float: left }　　.tc{ text-align:center; }　　.auto{ margin-left:auto; margin-right:auto; }</pre></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong
      
    
    </summary>
    
      <category term="CSS" scheme="http://blog.heavenbin.live/categories/CSS/"/>
    
    
      <category term="性能" scheme="http://blog.heavenbin.live/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》第十三章（4）</title>
    <link href="http://blog.heavenbin.live/2017/06/17/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%884%EF%BC%89/"/>
    <id>http://blog.heavenbin.live/2017/06/17/《JavaScript高级程序设计》第十三章（4）/</id>
    <published>2017-06-16T16:00:00.000Z</published>
    <updated>2018-09-02T18:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="5-内存和性能"><a href="#5-内存和性能" class="headerlink" title="5 内存和性能"></a>5 内存和性能</h2><p>添加到页面上的事件处理程序数量 关系到 整体运行性能<br>1.程序占用内存，导致性能下降<br>2.程序越多，整个页面的交互就绪时间就越长</p><hr><h4 id="5-1-事件委托"><a href="#5-1-事件委托" class="headerlink" title="5.1 事件委托"></a>5.1 事件委托</h4><p>事件委托：“事件处理程序过多”的解决方案 (利用事件冒泡)</p><p>例如：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>传统做法：为三个li元素分别添加事件<br>事件委托：为更高的层次ul添加一个事件即可，在通过target对象来甄别触发的目标元素</p><p>事件委托的优点：<br>Document对象可以很快访问，且可以在页面生命周期的任何时点上个为它添加事件处理程序。<br>减少就绪时间<br>减少内存占用</p><p>最适合的事件：click、mousedown、mouseup、keydown、keyup、keypress</p><hr><h4 id="5-2-移除事件处理程序"><a href="#5-2-移除事件处理程序" class="headerlink" title="5.2 移除事件处理程序"></a>5.2 移除事件处理程序</h4><p>目的是 移除那些不需要的事件处理程序<br>有两种情况需要注意：<br>从文档中移除带有事件处理程序的元素时 解决方案：手工移除btn.onclick = null;<br>卸载页面的时候 解决方案：onunload事件移除所有事件处理程序</p><hr><h2 id="6-模拟事件"><a href="#6-模拟事件" class="headerlink" title="6 模拟事件"></a>6 模拟事件</h2><p>DOM2级规范规定了模拟特定事件的方式，该冒泡还会冒泡，也会触发事件处理程序。</p><hr><h4 id="6-1-DOM中的事件模拟"><a href="#6-1-DOM中的事件模拟" class="headerlink" title="6.1 DOM中的事件模拟"></a>6.1 DOM中的事件模拟</h4><p>步骤一：创建event对象<br>Document对象上使用createEvent(事件类型的字符串) 创建event对象<br>事件类型的字符串：<br>UIEvents UI事件(鼠标和键盘事件都继承自UI事件) DOM3 UIEvent<br>MouseEvents 鼠标事件 DOM3 MouseEvent<br>MutationEvents DOM变动事件 DOM3 MutationEvent<br>HTMLEvents HTML事件 DOM3 被分散到其它类别中</p><p>步骤二：初始化event对象<br>每种类型的event对象都有一个特殊的方法，传入适当的数据来初始化。</p><p>步骤三：触发事件<br>元素的dispatchEvent(event对象) 触发事件</p><ul><li>1.模拟鼠标事件<br>var btn = document.getElementById(“myBtn”);<br>var event = document.createEvent(“MouseEvents”);<br>event.initMouseEvent(15个参数);<br>btn.dispatchEvent(event);</li></ul><p>15个参数：<br>type(字符串) 事件类型，例如：“click”<br>bubbles(布尔值) 是否冒泡<br>cancelable(布尔值) 是否可以取消<br>view(AbstractView) 与事件关联的视图<br>detail(整数) 与事件有关的详细信息<br>screenX<br>screenY<br>clientX<br>clientY<br>ctrlKey<br>altKey<br>shiftKey<br>metaKey<br>button(整数) 按下哪一个鼠标键，默认0<br>relatedTarget 与事件相关的对象</p><ul><li>2.模拟键盘事件<br>DOM3级<br>var event = document.createEvent(“KeyboardEvent”);<br>event.initKeyboardEvent(参数);<br><em>**</em>.dispatchEvent(event);</li></ul><p>Firefox中<br>var event = document.createEvent(“KeyEvents”);<br>event.initKeyEvent(参数);<br><em>**</em>.dispatchEvent(event);</p><p>具体参数P407-408 通用事件P409</p><ul><li><p>3.模拟其他事件<br>模拟变动事件<br>模拟HTML事件</p></li><li><p>4.自定义DOM事件<br>目的：让开发人员创建自己的事件<br>支持的浏览器：IE9+ Firefox6+</p></li></ul><hr><h4 id="6-2-IE中的事件模拟"><a href="#6-2-IE中的事件模拟" class="headerlink" title="6.2 IE中的事件模拟"></a>6.2 IE中的事件模拟</h4><p>思路相似，但是每个步骤都采用了不一样的方式。</p><p>var btn = doucument.getElementById(“myBtn”);<br>创建事件对象：<br>var event = document.createEventObject(); —-创建通用event对象</p><p>初始化事件对象：<br>event.<strong><strong> = ~~~~;<br>event.</strong></strong> = <del>~~;<br>event.<em>**</em> = ~</del>~;<br>…</p><p>触发事件：<br>btn.fireEvent(“onclick”,event); —-自动为event添加srcElement属性和type属性</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;事件&quot;&gt;&lt;a href=&quot;#事件&quot; class=&quot;headerlink&quot; title=&quot;事件&quot;&gt;&lt;/a&gt;事件&lt;/h1&gt;&lt;h2 id=&quot;5-内存和性
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.heavenbin.live/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript高级程序设计" scheme="http://blog.heavenbin.live/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》第十三章（3）</title>
    <link href="http://blog.heavenbin.live/2017/06/12/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%883%EF%BC%89/"/>
    <id>http://blog.heavenbin.live/2017/06/12/《JavaScript高级程序设计》第十三章（3）/</id>
    <published>2017-06-11T16:00:00.000Z</published>
    <updated>2018-09-02T18:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="4-事件类型"><a href="#4-事件类型" class="headerlink" title="4 事件类型"></a>4 事件类型</h2><h4 id="4-4-键盘与文本事件"><a href="#4-4-键盘与文本事件" class="headerlink" title="4.4 键盘与文本事件"></a>4.4 键盘与文本事件</h4><p>三个键盘事件：<br>keydown 用户按下键盘上的任意键 按住不放重复触发<br>keypress 用户按下键盘上的字符键 按住不放重复触发<br>keyup 用户释放键盘上的键</p><p>字符键 keydown —&gt; keypress —&gt; keyup<br>非字符键 keydown —&gt; keyup</p><p>键盘事件对象中也有shiftKey、ctrlKey、altKey、metaKey属性</p><p>一个文本事件：<br>textInput 在文本插入文本框之前 (对keypress的补充)</p><ul><li>1.键码<br>keydown和keyup事件对象都有一个keyCode属性(值与键盘上一个特定的键对应)</li></ul><p>数字字母字符键 键码 与 ASCII码中对应小写字母或数字的编码 相同 (7 -&gt; 55, A -&gt; 65)<br>非字符键 键码P380</p><p>也会存在一些特殊情况。</p><ul><li>2.字符编码<br>keypress在按下能够插入或删除字符的键时都会触发，支持一个charCode属性(值与代表字符的ASCII编码相同)</li></ul><p>此时keyCode值可能是0，也可能是键码<br>跨浏览器的方式取得字符编码 P381</p><ul><li>3.DOM3级变化<br>DOM3级不再包含charCode属性，新添加属性和方法：<br>key 字符串 (字符键“k” 非字符键“Shift”)<br>char 字符串 (字符键“k” 非字符键 null) IE不支持<br>keyIdentifier 字符串 (字符键“U+0000” 非字符键“Shift”) Safari5 Chrome支持<br>location 0默认键盘 1左侧位置 2右侧位置 3数字小键盘 4移动设备键盘 5手柄<br>getModifierState(修改键字符串) 检测修改键是否活动中 仅IE9支持</li></ul><p>在跨浏览器开发中不推荐使用这些属性方法。</p><ul><li>4.textInput事件<br>textInput事件 用户在可编辑区域中输入字符时触发</li></ul><p>与keypress区别：<br>keypress 任何可以获得焦点的元素就行 textInput 只有可编辑区域才算<br>keypress (退格键也算) textInput 只有输入实际字符才算</p><p>特有属性：<br>data 用户输入的字符(“S” “k”)<br>inputMethod 文本输入到文本框的方式(仅IE支持)<br>0不确定 1键盘 2粘贴 3拖放 4IME 5表单选择 6手写输入 7语音输入 8组合输入 9脚本</p><ul><li>5.设备中的键盘事件<br>任天堂Wii会触发键盘事件，不是全部<br>iOS版Safari和Android版WebKit 都会触发键盘事件</li></ul><hr><h4 id="4-5-复合事件"><a href="#4-5-复合事件" class="headerlink" title="4.5 复合事件"></a>4.5 复合事件</h4><p>复合事件：用于处理IME的输入序列。<br>IME：输入法编辑器，可以输入物理键盘上找不到的字符，通常需要同时按住多个键，最终只输入一个字符。</p><p>compositionstart IME的文本复合系统打开时(表示要开始输入了) data正在编辑的文本<br>compositionupdate 向输入字段中插入新字符 data正在插入的新字符<br>compositionend IME的文本复合系统关闭时(表示返回正常键盘输入状态) data会话中插入的所有字符<br>这些事件对象的特有data属性</p><p>IE9+是2011年唯一支持复合事件的浏览器，由于缺少支持，所以用处不大。</p><hr><h4 id="4-6-变动事件"><a href="#4-6-变动事件" class="headerlink" title="4.6 变动事件"></a>4.6 变动事件</h4><p>变动事件：能在DOM中的某一部分发生变化时给出提示。(为XML/HTML DOM设计的)</p><p>下面是DOM2级定义的变动事件<br>DOMSubtreeModified DOM结构发生任何变化时触发(任何事件触发都会触发)<br>DOMNodeInserted 节点作为子节点插入另一个节点<br>DOMNodeRemoved 节点从其父节点中被移除<br>DOMNodeInsertedIntoDocument 节点 直接或间接 插入文档之后 (DOMNodeInserted之后触发)<br>DOMNodeRemovedFromDocument 节点 直接或间接 移出文档之前 (DOMNodeRemoved之后触发)<br>DOMAttrModified 节点特性被修改之后<br>DOMCharacterDataModified 文本节点的值发生变化时</p><p>DOM3级作废了很多变动事件，下面只介绍还支持的。</p><ul><li>1.删除节点<br>用removeChild()或者replaceChild()从DOM中删除ul节点时<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>ul 触发DOMNodeRemoved事件(event.target == ul,event.relatedNode == body) 冒泡<br>ul及其所有子节点 触发DOMNodeRemovedFromDocument事件(event.target == 被触发的元素) 不会冒泡<br>body 触发DOMSubtreeModified事件</p><ul><li>2.插入节点<br>用appendChild()、replaceChild()或者insertBefore()向DOM中插入li节点时<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>li 触发DOMNodeInserted 事件(event.target == 被插入的元素,event.relateNode == ul) 冒泡<br>li 触发DOMNodeInsertedIntoDocument事件(event.target == 被插入的元素) 不会冒泡<br>ul 触发DOMSubtreeModified事件</p><hr><h4 id="4-7-HTML5事件"><a href="#4-7-HTML5事件" class="headerlink" title="4.7 HTML5事件"></a>4.7 HTML5事件</h4><p>浏览器出于不同的目的，实现了一些自定义的事件。这里只讨论支持比较完善的事件。</p><ul><li><p>1.contextmenu事件<br>contextmenu用以表示何时应该显示上下文菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单。P389</p></li><li><p>2.beforeunload事件<br>beforeunload为了让开发人员有可能在页面卸载前组织这一操作，通常就是弹出对话框，将控制权交给用户。P390</p></li><li><p>3.DOMContentLoaded事件<br>load 一切都加载完毕<br>DOMContentLoaded 形成完整DOM树之后触发，不理会图像、JS文件、CSS文件</p></li></ul><p>DOMContentLoaded 早于load触发，这样用户可以更早地交互。</p><p>如果不支持这个事件，建议setTimeout(function(){ <del>~</del> },0);必须作为页面中的第一个超时调用。</p><ul><li>4.readystatechange事件<br>IE为DOM文档的某些部分提供readystatechange事件，目的是提供与文档或元素的加载状态有关的信息。<br>同时也为DOM对象提供readyState属性：<br>uninitialized 未初始化<br>loading 正在加载<br>loaded 加载完毕 (加载数据完成)<br>interactive 交互<br>complete 完成 (加载完毕)</li></ul><p>每个DOM对象未必拥有全部状态，通常readystatechange事件触发会少于4次</p><p>对比DOMContentLoaded事件 (还不如用DOMContentLoaded)<br>document的interactive状态，与DOMContentLoaded事件触发的时刻基本相同。</p><p>对比load事件 (还不如用DOMContentLoaded)<br>当加载东西多的时候，document的interactive状态 早于 load事件<br>当加载东西少的时候，不一定</p><p>支持readystatechange事件的浏览器有IE、Firfox4+、Opera</p><p>script(在IE和Opera中)和link(仅IE)元素也会触发readystatechange事件 P392</p><ul><li>5.pageshow和pagehide事件<br>Firefox和Opera有一个特性，“往返缓存”(bfcache)，能够加快“后退”/“前进”的转换速度。(转换不触发load事件)<br>为了更形象地说明bfcache的行为，Firefox提供了pageshow事件、pagehide事件。都添加到window对象上</li></ul><p>pageshow事件 重新加载页面(load之后触发) bfcache页面(页面完全恢复的那一刻触发)<br>它的persisted属性 页面是否被保存在bfcache</p><p>pagehide事件 浏览器卸载页面(unload之前触发)<br>它的persisted属性 卸载之后页面是否被保存在bfcache</p><p>支持这两个事件的浏览器有Firefox、Safari5+、Chrome、Opera</p><ul><li>6.hashchange事件<br>hashchange事件 当URL的参数列表发生变化时触发(必须添加到window对象上)<br>它的属性：oldURL (变化前的URL) newURL (变化后的URL)</li></ul><p>支持hashchange事件的浏览器：IE8+、Firefox3.6+、Safari5+、Chrome、Opera10.6+<br>支持它的两个属性的浏览器：Firefox6+、Chrome、Opera，所以推荐用location来确定当前的参数列表</p><hr><h4 id="4-8-设备事件"><a href="#4-8-设备事件" class="headerlink" title="4.8 设备事件"></a>4.8 设备事件</h4><p>设备事件：让开发人员确定用户在怎样使用设备。</p><ul><li><p>1.orientationchange事件<br>苹果公司为移动Safari添加(所有的iOS设备都支持，添加到window对象上)：<br>orientationchange事件 用户改变设备的查看模式时触发<br>window.orientation属性 0肖像模式 90左旋转的横向模式 -90右旋转的横向模式</p></li><li><p>2.MozOrientation事件 (实验性API)<br>Firefox3.6引入MozOrientation事件，当设备的加速计检测到设备方向改变时触发。(添加到window对象上)<br>event对象包含三个属性：x,y,z 当设备处于竖直状态(0,0,1)</p></li></ul><p>只有带加速计的设备才支持MozOrientation事件。</p><ul><li>3.deviceorientation事件<br>deviceorientation事件，当设备的加速计检测到设备方向改变时触发。(添加到window对象上)</li></ul><p>对比MozOrientation，这个事件更多的意图是告诉开发人员设备在空间中朝向哪儿。<br>event对象包含五个属性：<br>alpha 在围绕Z轴旋转时，y轴的度数差(0到360)<br>beta 在围绕x轴旋转时，z轴的度数差(-180到180)<br>gamma 在围绕y轴旋转时，z轴的度数差(-90到90)<br>absolute 是否返回一个绝对值<br>compassCalibrated 指南针是否校准过</p><p>支持的浏览器有：iOS4.2+的Safari、Chrome和Android版WebKit。</p><ul><li>4.devicemotion事件<br>devicemotion事件，告诉开发人员设备什么时候移动，而不仅仅是设备方向如何改变。(添加到window对象上)<br>event对象的属性：<br>acceleration 包含x,y,z属性的对象，不考虑重力的情况下，告诉你每个方向的加速度<br>accelerationIncludingGravity …考虑Z轴重力的情况下，….<br>interval 以毫秒表示的时间值<br>rotationRate 一个包含alpha、beta、gamma属性的对象</li></ul><p>支持的浏览器有：iOS4.2+的Safari、Chrome和Android版WebKit。</p><hr><h4 id="4-9-触摸与手势事件"><a href="#4-9-触摸与手势事件" class="headerlink" title="4.9 触摸与手势事件"></a>4.9 触摸与手势事件</h4><p>W3C开始制定Touch Events规范。下面的事件只针对触摸设备。</p><ul><li>1.触摸事件<br>touchstart 当手指触摸屏幕时触发 (即使已经有手指在屏幕上)<br>touchmove 当手指在屏幕上滑动时连续触发 (调用preventDefault()可以阻止滚动)<br>touchend 当手指从屏幕上移开时触发<br>touchcancel 当系统停止跟踪触摸时触发<br>这几个事件都会冒泡，也都可以取消。</li></ul><p>event对象的属性：<br>提供了鼠标事件的常见属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、 altKey、shiftKey、ctrlKey、metaKey。</p><p>三个用于跟踪触摸的属性：<br>touches 当前跟踪的触摸操作的Touch对象的数组<br>targetTouchs 特定于事件目标的Touch对象的数组<br>changeTouches 自上次触摸以来发生了什么改变的Touch对象的数组</p><p>每个Touch对象包含的属性：<br>clientX 触摸目标在视口中的x坐标<br>clientY 触摸目标在视口中的y坐标<br>pageX 触摸目标在页面中的x坐标<br>pageY 触摸目标在页面中的y坐标<br>screenX 触摸目标在屏幕中的x坐标<br>screenY 触摸目标在屏幕中的y坐标<br>target 触摸的DOM节点目标<br>identifier 标识触摸的唯一ID</p><p>在触摸屏幕上的元素时，这些事件(包括鼠标事件)发生的顺序如下：<br>touchstart<br>mouseover<br>mousemove (一次)<br>mousedown<br>mouseup<br>click<br>touchend</p><p>支持触摸事件的浏览器包括：<br>iOS版的Safari、Android版WebKit、baba版Dolfin、OS6+中的BlackBerryWebKit、……</p><ul><li>2.手势事件<br>当两个手指触摸屏幕时就会产生手势<br>gesturestart 一个手指已经按在屏幕上，另一个手指又触摸屏幕时触发<br>gesturechange 触摸屏幕的任何一个手指位置变化时触发<br>gestureend 任何一个手指移开时触发<br>这几个事件都会冒泡，所以可以放在文档上处理所有手势事件。</li></ul><p>event对象的属性：<br>提供了鼠标事件的常见属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、 altKey、shiftKey、ctrlKey、metaKey。</p><p>两个额外的属性：<br>rotation 手指变化引起的旋转角度(起始0，逆时针负值，顺时针正值)<br>scale 两个手指间的距离变化情况(起始1)</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;事件&quot;&gt;&lt;a href=&quot;#事件&quot; class=&quot;headerlink&quot; title=&quot;事件&quot;&gt;&lt;/a&gt;事件&lt;/h1&gt;&lt;h2 id=&quot;4-事件类型
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.heavenbin.live/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript高级程序设计" scheme="http://blog.heavenbin.live/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》第十三章（2）</title>
    <link href="http://blog.heavenbin.live/2017/06/02/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%882%EF%BC%89/"/>
    <id>http://blog.heavenbin.live/2017/06/02/《JavaScript高级程序设计》第十三章（2）/</id>
    <published>2017-06-01T16:00:00.000Z</published>
    <updated>2018-09-02T18:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="3-事件对象"><a href="#3-事件对象" class="headerlink" title="3 事件对象"></a>3 事件对象</h2><p>event对象：包含着所有与事件有关的信息。<br>所有浏览器都支持event对象，但支持方式不同。</p><hr><h4 id="3-1-DOM中的事件对象"><a href="#3-1-DOM中的事件对象" class="headerlink" title="3.1 DOM中的事件对象"></a>3.1 DOM中的事件对象</h4><p>兼容DOM的浏览器会将一个event对象传入到事件处理程序中。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">“button”</span> <span class="attr">value</span>=<span class="string">“Click</span> <span class="attr">Me</span>” <span class="attr">onclick</span>=<span class="string">“alert(event.type)”/</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>btn.onclick = function(event){};</p><p>btn.addEventListener(“click”, function(event){}, false)</p><p>它的属性和方法(全部只读)：<br>bubbles 是否冒泡 (Boolean)<br>cancelable 是否可以取消事件的默认行为 (Boolean)<br>currentTarget 其事件处理程序当前正在处理事件的那个元素 (Element)<br>defaultPrevented 是否已经调用了preventDefault() (Boolean)<br>detail 与事件相关的细节信息 (Integer)<br>eventPhase 1 捕获阶段 2 处于目标 3 冒泡阶段 (Integer)<br>preventDefault() 取消事件的默认行为<br>stopImmediatePropagation() 取消进一步捕获或冒泡，且阻止任何事件程序调用<br>stopPropagation() 取消进一步捕获或冒泡，bubbles才可调用这方法<br>target 事件的目标 (Element)<br>trusted true浏览器生成 false开发人员生成 (Boolean)<br>type 被触发的事件的类型 (String)<br>view 与事件关联的抽象视图，等同于它的window对象</p><p>1.使用type可以通过一个函数处理多个事件<br>2.preventDefault()可以阻止链接导航这一默认行为<br>3.stopPropagation()可以取消进一步捕获或冒泡<br>4.eventPhase 可以用来确定事件当前正位于事件流的哪个阶段</p><hr><h4 id="3-2-IE中的事件对象"><a href="#3-2-IE中的事件对象" class="headerlink" title="3.2 IE中的事件对象"></a>3.2 IE中的事件对象</h4><p>访问IE中的event对象有几种不同的方式：<br>DOM0级： window.event<br>attachEvent: event参数/window.event<br>HTML： event变量</p><p>它的属性和方法：<br>cancelBubble 默认false，true表示取消事件冒泡 (Boolean 读/写)<br>returnValue 默认true，false表示取消事件的默认行为(Boolean 读/写)<br>srcElement 事件的目标 (Element 只读)<br>type 被触发的事件类型 (String 只读)</p><p>1.this未必始终等于事件目标，用srcElement比较保险<br>2.returnValue 相当于 preventDefault()<br>3.cancelBubble 相当于 stopPropagation() 但是不支持事件捕获</p><hr><h4 id="3-3-跨浏览器的事件对象"><a href="#3-3-跨浏览器的事件对象" class="headerlink" title="3.3 跨浏览器的事件对象"></a>3.3 跨浏览器的事件对象</h4><p>根据DOM、IE中的事件对象，自己写一个EventUtil工具对象来实现跨浏览器</p><hr><h2 id="4-事件类型"><a href="#4-事件类型" class="headerlink" title="4 事件类型"></a>4 事件类型</h2><p>“DOM3级事件”：<br>UI事件 用户与页面上的元素交互<br>焦点事件 元素获得或者失去焦点<br>鼠标事件 用户通过鼠标在页面上执行操作<br>滚轮事件 使用鼠标滚轮<br>文本事件 在文档中输入文本时<br>键盘事件 用户通过键盘在页面上执行操作时<br>合成事件 为IME(输入法)输入字符时触发<br>变动事件 底层DOM结构发生变化时<br>变动名称事件 已经被废弃，不做介绍</p><p>除此之外，还有HTML5事件，浏览器的专有事件。<br>DOM3级事件模块 在 DOM2级事件模块 的基础上重新定义了这些事件，也添加了一些事件。</p><hr><h4 id="4-1-UI事件"><a href="#4-1-UI事件" class="headerlink" title="4.1 UI事件"></a>4.1 UI事件</h4><p>DOMActivate 元素已经被用户操作激活(DOM3废弃，不建议使用)<br>load 页面/框架/图片/嵌入内容 完全加载 window/框架集/<img>/<object>上触发<br>unload 页面/框架/图片/嵌入内容 完全卸载 window/框架集/<img>/<object>上触发<br>abort 在用户停止下载过程时，嵌入内容未加载完，<object>上触发<br>error 页面/框架/图片/嵌入内容 出现错误 window/框架集/<img>/<object>上触发<br>select 当用户选择文本框(input)或(texterea)中的一或多个字符时触发<br>resize 窗口/框架 大小变化 window/框架 上触发<br>scroll 当用户滚动带滚动条的元素中的内容时，在该元素上面触发。</object></object></object></object></p><p>除DOMActivete之外，其它事件都归为HTML事件</p><ul><li><p>1.load事件<br>两种方式定义onload事件处理程序：JavaScript(推荐) / 添加元素特性<br>比如：window(</p><body>)、img、script<p></p></body></li><li><p>2.unload事件<br>两种方式定义onunload事件处理程序：JavaScript(推荐) / 添加元素特性<br>最多的情况：清除引用，以避免内存泄漏<br>注意：编写代码注意有些对象已经不存在了</p></li><li><p>3.resize事件<br>两种方式定义onresize事件处理程序：JavaScript(推荐) / 添加元素特性<br>关于何时会触发resize事件，不同浏览器有不同的机制。<br>注意：不要写入大量的计算代码，影响性能</p></li><li><p>4.scroll事件<br>虽然scroll事件是在window对象上发生的，但它实际表示的则是页面中相应元素的变化。<br>注意：不要写入大量的计算代码，影响性能</p></li></ul><hr><h4 id="4-2-焦点事件"><a href="#4-2-焦点事件" class="headerlink" title="4.2 焦点事件"></a>4.2 焦点事件</h4><p>focus 元素获得焦点 (早期 不会冒泡)<br>blur 元素失去焦点 (早期 不会冒泡)</p><p>DOMFocusIn 元素获得焦点 (Opera 会冒泡)<br>DOMFocusOut 元素失去焦点 (Opera 会冒泡)</p><p>focusin 元素获得焦点 (IE纳入DOM3 会冒泡)<br>focusout 元素失去焦点 (IE纳入DOM3 会冒泡)</p><p>利用这些事件与document.hasFocus()方法及document.activeElement属性配合，可以知道用户行踪。</p><hr><h4 id="4-3-鼠标与滚轮事件"><a href="#4-3-鼠标与滚轮事件" class="headerlink" title="4.3 鼠标与滚轮事件"></a>4.3 鼠标与滚轮事件</h4><p>click 用户单击主鼠标按钮/按下回车键<br>dblclick 用户双击鼠标按钮</p><p>mousedown 用户按下了任意鼠标按钮<br>mouseup 用户释放鼠标按钮</p><p>mouseenter 鼠标光标刚进入 元素范围(不冒泡)<br>mouseleave 鼠标光标刚离开元素范围(不冒泡)<br>mousemove 鼠标光标在元素范围内移动</p><p>mouseout 鼠标光标刚进入 元素或其子元素 范围<br>mouseover 鼠标光标刚离开 元素或其子元素 范围</p><p>mousewheel 滚轮事件</p><p>4个事件的触发顺序：<br>mousedown mouseup click<br>mousedown mouseup click<br>dblclick</p><p>click 和 dblclick都会依赖其他先行事件的触发</p><ul><li>1.客户区坐标位置<br>clientX 事件发生时鼠标指针在视口中的水平坐标<br>clientY 事件发生时鼠标指针在视口中的垂直坐标</li></ul><p>因为只是相对于视口，不包括被挡住的滚轮距离，所以不能代表鼠标在页面上的位置。</p><ul><li>2.页面坐标位置<br>pageX 事件发生时鼠标指针在页面中的水平坐标<br>pageY 事件发生时鼠标指针在页面中的垂直坐标</li></ul><p>在页面没有滚动的情况下，pageX和pageY的值与clientX和clientY的值相等。</p><ul><li><p>3.屏幕坐标位置<br>screenX 事件发生时鼠标指针在整个屏幕中的水平坐标<br>screenY 事件发生时鼠标指针在整个屏幕中的垂直坐标</p></li><li><p>4.修改键<br>修改键：<br>Shift 对应属性 shiftKey<br>Ctrl 对应属性 ctrlKey<br>Alt 对应属性 altKey<br>Meta 对应属性 metaKey (windows键盘的window键，Mac键盘的Cmd键)</p></li></ul><p>这些属性值为true，说明触发事件时同时按下这些键</p><ul><li>5.相关元素<br>仅对于mouseover、mouseout事件提供的relatedTarget属性，其它事件为null。</li></ul><p>mouseover事件 刚进入元素(被离开的元素为相关元素) relatedTarget fromElement(IE8)<br>mouseout事件 刚离开元素(被进入的元素为相关元素) relatedTarget toElement(IE8)</p><ul><li>6.鼠标按钮<br>button属性 0/1/2 按下或释放 主鼠标按钮/中间的鼠标按钮/次鼠标按钮</li></ul><p>这个属性对于mousedown、mouseup事件来说挺有用的。<br>IE8及之前版本也有button属性，有很大差异。</p><ul><li>7.更多的事件信息<br>detail属性 在给定位置上发生了多少次单击 (从1开始计数，换位置则为0)</li></ul><p>IE提供了下列属性：<br>altLeft 是否按下Alt键<br>ctrlLeft 是否按下Ctrl键<br>shiftLeft 是否按下Shift键<br>offsetX 光标相对于目标元素边界的x坐标<br>offsetY 光标相对于目标元素边界的y坐标<br>这些属性用处并不大，一是仅IE支持，二是可以通过其它方式获得。</p><ul><li>8.鼠标滚轮事件<br>mousewheel事件 用户通过鼠标滚轮与页面交互，在垂直方向上滚动页面时触发<br>提供特殊的wheelDelta属性 120的倍数/-120的倍数 表示 向前滚动/向后滚动</li></ul><p>Opera9.5之前的版本，wheelDelta值的正负号是颠倒的。<br>Firefox支持一个名为DOMMouseScroll的类似事件，特殊属性则是detail<br>跨浏览器方案：P377</p><ul><li><p>9.触摸设备<br>iOS和Android设备的实现非常特别，因为这些设备没有鼠标。<br>在面向iPhone和iPod中的Safari开发时，要记住以下坑：<br>不支持dblclick事件。<br>轻击可单击元素会触发mousemove事件。<br>mousemove事件也会触发mouseover和mouseout事件<br>两个手指放在屏幕上且页面随手指移动而滚动时会触发mousewheel和scroll事件</p></li><li><p>10.无障碍性问题<br>确保残疾人特别是那些使用屏幕阅读器的人都能访问，使用鼠标事件时应当注意几个访问性问题：<br>使用click事件执行代码。<br>不要使用onmouseover向用户显示新的选项。<br>不要使用dblclick执行重要的操作。</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;事件&quot;&gt;&lt;a href=&quot;#事件&quot; class=&quot;headerlink&quot; title=&quot;事件&quot;&gt;&lt;/a&gt;事件&lt;/h1&gt;&lt;h2 id=&quot;3-事件对象
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.heavenbin.live/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript高级程序设计" scheme="http://blog.heavenbin.live/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》第十三章（1）</title>
    <link href="http://blog.heavenbin.live/2017/05/28/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%881%EF%BC%89/"/>
    <id>http://blog.heavenbin.live/2017/05/28/《JavaScript高级程序设计》第十三章（1）/</id>
    <published>2017-05-27T16:00:00.000Z</published>
    <updated>2018-09-02T18:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>JavaScript与HTML之间的交互是通过事件实现的。使用侦听器(或处理程序)来预订事件(观察员模式)<br>浏览器全都实现了“DOM2级事件”，IE8是最后一个仍然使用其专有事件系统的主要浏览器</p><hr><h2 id="1-事件流"><a href="#1-事件流" class="headerlink" title="1 事件流"></a>1 事件流</h2><p>事件流：从页面中接收事件的顺序 IE的事件流(事件冒泡流) Netscape的事件流(事件捕获流)</p><hr><h4 id="1-1-事件冒泡"><a href="#1-1-事件冒泡" class="headerlink" title="1.1 事件冒泡"></a>1.1 事件冒泡</h4><p>事件冒泡：最具体的节点 —-&gt; 不太具体的节点</p><p></p><div>—&gt;<body>—&gt;<html>—&gt; document —&gt; window<p></p><hr><h4 id="1-2-事件捕获"><a href="#1-2-事件捕获" class="headerlink" title="1.2 事件捕获"></a>1.2 事件捕获</h4><p>事件捕获：不太具体的节点 —-&gt; 最具体的节点<br>window —&gt; document —&gt;</p><html>—&gt;<body>—&gt;<div><p></p><p>很少用事件捕获(老版本的浏览器不支持)，基本都用事件冒泡</p><hr><h4 id="1-3-DOM事件流"><a href="#1-3-DOM事件流" class="headerlink" title="1.3 DOM事件流"></a>1.3 DOM事件流</h4><p>DOM事件流包括三个阶段：事件捕获阶段 —&gt; 处于目标阶段 —&gt; 事件冒泡阶段</p><p>window —&gt; document —&gt;</p><html>—&gt;<body>—&gt;<div>—&gt;<body>—&gt;<html>—&gt; document —&gt; window<br>绿色部分(事件捕获阶段) —- 包括 处于目标阶段(浏览器实现)<br>红色部分(处于目标阶段)<br>蓝色部分(事件冒泡阶段) —- 包括 处于目标阶段(DOM规定)<p></p><hr><h2 id="2-事件处理程序"><a href="#2-事件处理程序" class="headerlink" title="2 事件处理程序"></a>2 事件处理程序</h2><p>事件 用户或浏览器自身执行的某种动作 click<br>事件处理程序 事件处理程序(事件侦听器) onclick</p><p>为事件指定处理程序的方式有好几种</p><hr><h4 id="2-1-HTML事件处理程序"><a href="#2-1-HTML事件处理程序" class="headerlink" title="2.1 HTML事件处理程序"></a>2.1 HTML事件处理程序</h4><p>某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定。</p><p><input type="“button”" value="“Click" me”="" onclick="“alert(‘Clicked’)”"> 为了避免使用HTML实体，使用单引号</p><p><input type="“button”" value="“Click" me”="" onclick="“showMessage()”"> 独到之处：函数里面有局部变量event 代表 事件对象，this代表 事件的目标元素</p><p>HTML事件处理程序的缺点：<br>1.页面解析程序之前，就触发了事件，就会引发错误。<br>解决方案：try{showMessage();} catch(ex){} 捕获错误，不会显示出来<br>2.在不同的浏览器中会导致不同的作用域链<br>3.改动的时候麻烦：需要改动HTML和JS代码两个地方。</p><hr><h4 id="2-2-DOM0级事件处理程序"><a href="#2-2-DOM0级事件处理程序" class="headerlink" title="2.2 DOM0级事件处理程序"></a>2.2 DOM0级事件处理程序</h4><p>每个元素 都有自己的 事件处理程序属性<br>var btn = document.getElementById(“myBtn”);<br>btn.onclick = function() {}; —- this 代表 当前元素，相当于 元素的方法 (在冒泡阶段被处理)<br>btn.onclick = null; —- 删除事件处理程序</p><hr><h4 id="2-3-DOM2级事件处理程序"><a href="#2-3-DOM2级事件处理程序" class="headerlink" title="2.3 DOM2级事件处理程序"></a>2.3 DOM2级事件处理程序</h4><p>所有DOM节点都包含这两个方法(能够一个事件添加多个函数)：<br>addEventListener(事件名,处理函数,布尔值) 为事件指定处理程序 (只能用removeEventListener移除)<br>removeEventListener(事件名,处理函数,布尔值) 为事件移除处理程序 (无法移除匿名函数)<br>布尔值(true捕获阶段调用 false冒泡阶段调用)</p><p>var handler = function(){}<br>btn.addEventListener(“click”,handler,false)<br>btn.removeEventListener(“click”,handler,false)</p><p>推荐使用冒泡阶段(false)，最好只在需要在事件到达目标之前截获它的时候才用捕获阶段(true)</p><hr><h4 id="2-4-IE事件处理程序"><a href="#2-4-IE事件处理程序" class="headerlink" title="2.4 IE事件处理程序"></a>2.4 IE事件处理程序</h4><p>IE实现了类似的两个方法(能够一个事件添加多个函数，但是相反的顺序执行函数)：<br>attachEvent(处理程序名,处理函数) 为事件指定处理程序 (只能用detachEvent移除) 都是冒泡阶段 this 代表 window<br>detachEvent(处理程序名,处理函数) 为事件移除处理程序 (无法移除匿名函数)</p><p>var handler = function(){}<br>btn.attachEvent(“onclick”,handler)<br>btn.detachEvent(“onclick”,handler)</p><hr><h4 id="2-5-跨浏览器的事件处理程序"><a href="#2-5-跨浏览器的事件处理程序" class="headerlink" title="2.5 跨浏览器的事件处理程序"></a>2.5 跨浏览器的事件处理程序</h4><p>结合DOM0级事件处理程序、DOM2级事件处理程序、IE事件处理程序，自己写addHandler()、removeHandler() P354</p></html></body></div></body></html></div></body></html></html></body></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;事件&quot;&gt;&lt;a href=&quot;#事件&quot; class=&quot;headerlink&quot; title=&quot;事件&quot;&gt;&lt;/a&gt;事件&lt;/h1&gt;&lt;p&gt;JavaScript与
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.heavenbin.live/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript高级程序设计" scheme="http://blog.heavenbin.live/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》第十二章（2）</title>
    <link href="http://blog.heavenbin.live/2017/05/21/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%882%EF%BC%89/"/>
    <id>http://blog.heavenbin.live/2017/05/21/《JavaScript高级程序设计》第十二章（2）/</id>
    <published>2017-05-20T16:00:00.000Z</published>
    <updated>2018-09-02T18:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h1 id="DOM2和DOM3"><a href="#DOM2和DOM3" class="headerlink" title="DOM2和DOM3"></a>DOM2和DOM3</h1><h2 id="3-遍历"><a href="#3-遍历" class="headerlink" title="3 遍历"></a>3 遍历</h2><p>“DOM2级遍历和范围”模块定义了两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator、TreeWalker<br>它们能够基于给定的起点对DOM结构执行深度优先(depth-first)的遍历操作。<br>(遍历以给定节点为根，不可能向上超出DOM树的根节点 IE不支持DOM遍历)</p><hr><h4 id="3-1-NodeIterator"><a href="#3-1-NodeIterator" class="headerlink" title="3.1 NodeIterator"></a>3.1 NodeIterator</h4><p>document.createNodeIterator() 创建NodeIterator类型的实例 返回Node的迭代器<br>参数：root 想要作为搜索起点的树中的节点<br>whatToShow 要访问哪些节点的数字代码 (位掩码，参数的值P328)<br>filter NodeFilter对象或函数 (筛选是否访问)<br>entityReferenceExpansion 布尔值，是否要扩展实体引用</p><p>这个实例提供两个方法(这样就可以遍历了)：<br>nextNode() 到下一个节点(没有的时候返回null)<br>previousNode() 到上一个节点(没有的时候返回null)</p><p>filter返回值：<br>NodeFilter.FILTER_ACCEPT 可以加入迭代器<br>NodeFilter.FILTER_SKIP 跳过这个节点</p><hr><h4 id="3-2-TreeWalker"><a href="#3-2-TreeWalker" class="headerlink" title="3.2 TreeWalker"></a>3.2 TreeWalker</h4><p>相当于NodeIterator的一个更高级的版本。<br>document.createTreeWalker() 创建TreeWalker类型的实例 返回Node的迭代器<br>参数：与createNodeIterator一致<br>比createNodeIterator多的属性和方法：<br>parentNode() 到当前节点的父节点<br>firstChild() 到当前节点的第一个子节点<br>lastChild() 到当前节点的最后一个子节点<br>nextSibling() 到当前节点的下一个同辈节点<br>previousSibling() 到当前节点的上一个同辈节点<br>currentNode 在上一次遍历中返回的节点</p><p>filter返回值(多一个)：<br>NodeFilter.FILTER_REJECT 跳过这个节点及其整个子树</p><p>TreeWalker更加灵活，但是IE中没有对应的类型和方法。</p><hr><h2 id="4-范围"><a href="#4-范围" class="headerlink" title="4 范围"></a>4 范围</h2><p>“DOM2级遍历和范围”模块定义了“范围”接口，可以用来选择文档的一个区域，而不考虑节点的界限。<br>在常规的DOM操作不能更有效地修改文档时，使用范围往往可以达到目的。</p><hr><h4 id="4-1-DOM中的范围"><a href="#4-1-DOM中的范围" class="headerlink" title="4.1 DOM中的范围"></a>4.1 DOM中的范围</h4><p>DOM2级在Document类型中定义了createRange()方法，用来创建DOM范围。<br>(与节点相似，与文档关联，不可用于其它文档那个)<br>var range = document.createRange();</p><p>每个范围(Range类型的实例) 属性和方法：<br>startContainer 包含范围起点的节点(即选区中第一个节点的父节点)<br>startOffset 范围在startContainer中起点的偏移量<br>endContainer 包含范围终点的节点(即选区中最后一个节点的父节点)<br>endOffset 范围在endContainer中终点的偏移量<br>commonAncestorContainer startContainer、endContainer共同的祖先节点在文档树中位置最深的那个</p><ul><li>1.用DOM范围实现简单选择<br>DOM范围的方法：<br>selectNode(节点) 选择整个节点，包括其子节点 —-1<br>selectNodeContents(节点) 只选择节点的子节点 —-2<br><p id="“p1”"><b>Hello</b> world!</p>红色为2 全部为1</li></ul><p>更精确的方法<br>setStartBefore(节点) 将范围的起点设置在参数节点之前<br>setStartAfter(节点) 将范围的起点设置在参数节点之后<br>setEndBefore(节点) 将范围的终点设置在参数节点之前<br>setEndAfter(节点) 将范围的终点设置在参数节点之后</p><ul><li>2.用DOM范围实现复杂选择<br>DOM范围的方法：<br>setStart(参照节点,偏移量值) 对应设置startContainer、startOffset<br>setEnd(参照节点,偏移量值) 对应设置endContainer、endOffset</li></ul><p>它们更胜一筹的地方在于 能够选择节点的一部分</p><ul><li><p>3.操作DOM范围中的内容</p></li><li><p>4.插入DOM范围中的内容</p></li><li><p>5.折叠DOM范围</p></li><li><p>6.比较DOM范围</p></li><li><p>7.复制DOM范围</p></li><li><p>8.清理DOM范围</p></li></ul><hr><h4 id="4-2-IE8及更早版本中的范围-略"><a href="#4-2-IE8及更早版本中的范围-略" class="headerlink" title="4.2 IE8及更早版本中的范围(略)"></a>4.2 IE8及更早版本中的范围(略)</h4><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;DOM2和DOM3&quot;&gt;&lt;a href=&quot;#DOM2和DOM3&quot; class=&quot;headerlink&quot; title=&quot;DOM2和DOM3&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.heavenbin.live/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript高级程序设计" scheme="http://blog.heavenbin.live/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》第十二章（1）</title>
    <link href="http://blog.heavenbin.live/2017/05/17/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%881%EF%BC%89/"/>
    <id>http://blog.heavenbin.live/2017/05/17/《JavaScript高级程序设计》第十二章（1）/</id>
    <published>2017-05-16T16:00:00.000Z</published>
    <updated>2018-09-02T18:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h1 id="DOM2和DOM3"><a href="#DOM2和DOM3" class="headerlink" title="DOM2和DOM3"></a>DOM2和DOM3</h1><p>DOM1 定义的是HTML/XML文档的底层结构。<br>DOM2和DOM3 在这个结构的基础上引入更多的交互能力。(分为许多模块，且模块之间具有某种关联)</p><p>DOM2级核心(DOM Level 2 Core) 为节点添加了更多的方法和属性<br>DOM2级视图(DOM Level 2 Views) 为文档定义了基于样式信息的不同视图<br>DOM2级事件(DOM Level 2 Events) 说明了如何使用事件与DOM文档交互 —-13章<br>DOM2级样式(DOM Level 2 Style) 定义了如何以编程方式来访问和改变CSS样式信息<br>DOM2级遍历和范围(DOM Level 2 Traversal and Range) 遍历DOM文档和选择其特定部分的新接口<br>DOM2级HTML(DOM Level 2 HTML) 在1级HTML基础上，添加了更多属性、方法、接口</p><p>DOM3级 添加了 “XPath”模块 和 “加载与保存”(Load and Save)模块 —-18章</p><hr><h2 id="1-DOM变化"><a href="#1-DOM变化" class="headerlink" title="1 DOM变化"></a>1 DOM变化</h2><p>DOM2、DOM3目的是在于扩展DOM API，以满足操作XML的所有需求，同时提供更好的错误处理及特性检测能力。<br>DOM2没有引入新类型，DOM3引入了新类型。<br>DOM2级视图 和 DOM2级HTML 模块很小，将和 DOM2级核心 放在一起讨论</p><hr><h4 id="1-1-针对XML命名空间的变化"><a href="#1-1-针对XML命名空间的变化" class="headerlink" title="1.1 针对XML命名空间的变化"></a>1.1 针对XML命名空间的变化</h4><p>XML命名空间：可以将不同XML文档的元素混合在一起，共同构成格式良好的文档，而不同担心发生命名冲突了。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html xmlns=“http:<span class="comment">//www.w3.org/1999/xhtml”&gt;    //命名空间</span></span><br><span class="line">...</span><br><span class="line">&lt;svg xmlns=“http:<span class="comment">//www.w3.org/2000/svg” version=“fill:red”&gt;   //命名空间</span></span><br><span class="line">...</span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br><span class="line"><span class="regexp">...</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><p></p><p>元素属于哪个命名空间？ DOM2、DOM3提供了相关属性和方法。</p><p>1.Node类型的变化<br>DOM2提供属性，DOM3提供方法<br>2.Document类型的变化<br>DOM2提供方法<br>3.Element类型的变化<br>DOM2提供方法<br>4.NamedNodeMap类型的变化<br>提供了方法</p><hr><h4 id="1-2-其它方面的变化"><a href="#1-2-其它方面的变化" class="headerlink" title="1.2 其它方面的变化"></a>1.2 其它方面的变化</h4><p>讲的是“DOM2级核心”</p><ul><li>1.DocumentType类型的变化</li></ul><p>&lt;!DOCTYPE html PUBLIC “- //W3C//DTD XHTML 1.0 Strict//EN” 1<br>“<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd”" target="_blank" rel="noopener">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd”</a> 2<br>[&lt;!ELEMENT name (#PCDATA)&gt;] 3</p><blockquote></blockquote><p>新增3个属性：<br>document.doctype.publicId 文档类型声明中的第一个信息段 1<br>document.doctype.systemId 文档类型声明中的第二个信息段 2<br>document.doctype.internalSubset 文档类型声明的额外定义 3</p><p>三个属性在HTML中很少用到，XML中常见一些</p><ul><li>2.Document类型的变化<br>新增方法：<br>importNode(要复制的节点, 是否复制子节点) 取得一个节点，将其导入到另一个文档(与cloneNode方法非常相似)</li></ul><p>为document.implementation对象新增：<br>createDocumentType(文档类型名称,publicID,systemId) 创建DocumentType节点<br>createDocument() 创建新文档<br>三个参数：针对文档中元素的namespaceURI、文档元素的标签名、新文档的文档类型<br>“DOM2级HTML”添加：<br>createHTMLDocument(文档标题) 创建完整的HTML文档</p><p>“DOM2级视图” 添加：<br>defaultView属性 指向拥有给定文档的窗口或框架( IE parentWindow )</p><ul><li>3.Node类型的变化<br>新增方法：<br>isSupported(特性名,特性版本号) 确定当前节点是否具有这个能力( 与 hasFeature方法非常相似)<pre><code>未必准确，最好还是使用能力检测。</code></pre>DOM3新增：<br>isSameNode(一个节点) 传入节点和引用节点是否相同( 引用同一个对象 )<br>isEqualNode(一个节点) 传入节点和引用节点是否相等( 相同的类型 )</li></ul><p>setUserData(要设置的键,实际的数据，处理函数) 将数据指定给一个节点<br>getUserData(键) 获取键对应的数据</p><p>处理函数会在节点被复制、删除、重名名或引入一个文档时调用(接收5个参数，不细写了)</p><ul><li>4.框架的变化<br>HTMLFrameElement代表 框架 HTMLIFrameElement代表 内嵌框架<br>DOM2给它们新增属性：<br>contentDocument 指向表示框架内容的文档对象 (之前只能使用frames集合获得)<pre><code>也是Document类型的实例</code></pre>IE8之前不支持，但是有contentWindow属性。</li></ul><p>兼容性写法：<br>var iframe = document.getElementById(“myIframe”);<br>var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;</p><hr><h2 id="2-样式"><a href="#2-样式" class="headerlink" title="2 样式"></a>2 样式</h2><p>“DOM2级样式”模块围绕定义样式的3种方式提供了一套API。<br>方式一：link标签 包含 外部样式表文件<br>方式二：style标签 定义 嵌入式样式<br>方式三：style特性 定义 针对特定元素的样式</p><hr><h4 id="2-1-访问元素的样式"><a href="#2-1-访问元素的样式" class="headerlink" title="2.1 访问元素的样式"></a>2.1 访问元素的样式</h4><p>HTML元素的 style特性 对应 JS的 style属性 ( CSSStyleDeclaration的实例 )</p><p>CSS属性( 短划线 ) 对应 JS属性(驼峰大小写)<br>特殊CSS属性：float ==== cssFloat( DOM2级样式 ) ==== styleFloat(IE)</p><p>在JS中设置<br>myDiv.style.backgroundColor = “red”;</p><p>在元素中设置</p><div id="“myDiv”" style="“background-color:red"></div><ul><li><p>1.DOM样式属性和方法<br>为style对象定义了一些属性和方法：<br>cssText style特性中的CSS代码<br>读取模式(返回CSS代码的内部表示) 写入模式(重写整个style特性的值)<br>length CSS属性的数量<br>item(index) 返回给定位置的CSS属性的名称<br>getPropertyValue() 返回给定属性的字符串值<br>getPropertyCSSValue() 返回包含给定属性值的CSSValue对象<br>包含两个属性：cssText(属性的字符串值) cssValueType(0继承的值1基本的值2值列表3自定义的值)<br>getPropertyPriority() 使用了!important,返回important,否则返回空字符串<br>removeProperty() 删除给定属性<br>setProperty(属性名,属性值,标志) 设置属性值，并加上优先权标志(important/空字符串)</p></li><li><p>2.计算的样式<br>计算的样式：style特性+内嵌样式+外部样式，只读的。<br>为document.defaultView添加：<br>getComputedStyle( 计算的元素, 伪元素字符串[:after/..] ) 返回CSSStyleDeclaration对象(类似style属性)</p><pre><code>返回的对象包括style特性 + 内嵌的样式 + 外部样式</code></pre><p>IE不支持，但有currentStyle属性</p></li></ul><p>document.defaultView.getComputedStyle(myDiv,null); 对应 myDiv.currentStyle;</p><hr><h4 id="2-2-操作样式表"><a href="#2-2-操作样式表" class="headerlink" title="2.2 操作样式表"></a>2.2 操作样式表</h4><p>CSSStyleSheet类型 表示 样式表 (继承自 StyleSheet)</p><p>StyleSheet继承而来的属性：<br>….太多，略P317</p><p>document.styleSheets 文档的所有样式表集合 (不同浏览器返回的样式表也不同)<br>document.styleSheets.length 样式表的数量</p><p>获取CSSStyleSheet类型：<br>document.styleSheets[i] —-文档节点上获取<br>var link = document.getElementsByTagName(“link”)[0];<br>link.sheet(DOM规定) link.styleSheet(IE规定) —-元素节点上获取</p><ul><li>1.CSS规则<br>div.box{ —-一条规则<br>…<br>}</li></ul><p>CSSRule类型 表示 样式表中的每一条规则 (它是略中的属性)<br>CSSStyleRule类型 表示 样式信息 (继承自CSSRule)<br>CSSStyleRule类型包含的属性：<br>….太多，略P318<br>获取规则，修改规则的操作(略)</p><ul><li>2.创建规则<br>insertRule( 规则文本, 插入的索引 ) 在样式表中添加新规则<br>addRule( 选择符文本, CSS样式信息, 插入位置[可选] ) 类似方法(IE8及更早)</li></ul><p>var sheet = document.styleSheets[0];<br>sheet.insertRule(“body{ background-color: silver }”, 0);<br>sheet.addRule(“body”, “background-color: silver”, 0);</p><p>这种方式还是比较繁琐，不如第10章的动态加载样式表技术</p><ul><li>3.删除规则<br>deleteRule( 删除的位置 ) 在样式表中删除规则<br>removeRule( 删除的位置 ) 类似方法(IE)</li></ul><p>这种方式还是不好，不推荐</p><hr><h4 id="2-3-元素大小"><a href="#2-3-元素大小" class="headerlink" title="2.3 元素大小"></a>2.3 元素大小</h4><p>DOM中没有规定如何确定页面中元素的大小，IE引入了一些属性。很多浏览器都支持这些属性。</p><ul><li>1.偏移量 (元素与外部元素)<br>offsetHeight 元素的高度 + 上下边框高度 + 水平滚动条高度(像素)<br>offsetWidth 元素的宽度 + 左右边框高度 + 垂直滚动条宽度(像素)<br>offsetLeft 元素左外边框 至 外部元素左内边框 之间的距离(像素)<br>offsetTop 元素上外边框 至 外部元素上内边框 之间的距离(像素)<br>offsetParent 外部元素(包含元素)</li></ul><p>这些值都是只读的，访问需要重新计算，多次访问建议先保存在局部变量</p><ul><li>2.客户区大小 (元素内容与元素内边距) 不同浏览器值不一样<br>clientWidth 元素内容区宽度 + 左右内边距宽度<br>clientHeight 元素内容区高度 + 上下内边距高度</li></ul><p>这些值都是只读的，访问需要重新计算，多次访问建议先保存在局部变量</p><ul><li>3.滚动大小 (包含滚动内容的元素) 不同浏览器值不一样<br>scrollHeight 在没有滚动条的情况下，元素内容的总高度<br>scrollWidth 在没有滚动条的情况下，元素内容的总宽度<br>scrollLeft 被隐藏在内容区域左侧的像素数。 (可以设置滚动位置)<br>scrollTop 被隐藏在内容区域上方的像素数。 (可以设置滚动位置)</li></ul><p>clientHeight/Width = padding + height - 滚动条<br>offsetHeight/Width = padding + height + border = clientHeight + 滚动条 + 边框<br>scrollHeight/Width = padding + height (滚动大小：隐藏的内容也算)</p><ul><li>4.确定元素大小<br>getBoundingClientRect() 返回矩形对象(四个属性：left、top、right、bottom)<pre><code>元素在页面中相对视口的位置</code></pre></li></ul><p>不同浏览器的实现稍有不同，IE8及更早版本：左上角坐标(2,2)，其它浏览器：左上角坐标(0,0)</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;DOM2和DOM3&quot;&gt;&lt;a href=&quot;#DOM2和DOM3&quot; class=&quot;headerlink&quot; title=&quot;DOM2和DOM3&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.heavenbin.live/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript高级程序设计" scheme="http://blog.heavenbin.live/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》第十一章（2）</title>
    <link href="http://blog.heavenbin.live/2017/05/10/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%882%EF%BC%89/"/>
    <id>http://blog.heavenbin.live/2017/05/10/《JavaScript高级程序设计》第十一章（2）/</id>
    <published>2017-05-09T16:00:00.000Z</published>
    <updated>2018-09-02T18:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h1 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h1><h2 id="4-专有扩展"><a href="#4-专有扩展" class="headerlink" title="4 专有扩展"></a>4 专有扩展</h2><p>在编写这书的时候，这些大量的DOM扩展还没有成为标准。只得到少数浏览器的支持。</p><hr><h4 id="4-1-文档模式"><a href="#4-1-文档模式" class="headerlink" title="4.1 文档模式"></a>4.1 文档模式</h4><p>IE8 引入了“文档模式” (不同的模式使用不同级别的CSS，不同的JS API)<br>四种文档模式：IE5 IE7 IE8 IE9</p><p>强制浏览器以某种模式渲染页面：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=“X-UA-Compatible” content=“IE=IEVersion”&gt;</span><br></pre></td></tr></table></figure><p></p><p>IEVersion的值：<br>Edge 始终以最新的文档模式来渲染页面<br>EmulateIE9/8/7 有文档类型声明 IE9/8/7 没有 IE5<br>9/8/7/5 强制IE9/8/7/5</p><p>IE8提供了document.documentMode属性 (使用的文档模式)</p><hr><h4 id="4-2-children属性"><a href="#4-2-children属性" class="headerlink" title="4.2 children属性"></a>4.2 children属性</h4><p>IE9之前的版本与其它浏览器在处理文本节点中的空白符时有差异<br>children属性是HTMLCollection的实例。(除了只返回元素子节点，其它跟childNodes没有什么区别)</p><p>IE8及以前： children 还会包含注释节点(bug)<br>IE9之后： children 只包含元素节点</p><hr><h4 id="4-3-contains-方法"><a href="#4-3-contains-方法" class="headerlink" title="4.3 contains()方法"></a>4.3 contains()方法</h4><p>某个节点 是不是 另一个节点的后代</p><p>IE率先引入contains()<br>a节点.contains(b节点) b节点是不是a节点的后代 (true/false)</p><p>DOM Level 3 的compareDocumentPosition() 也能够确定节点间的关系。<br>返回一个表示该关系的位掩码<br>1 ==== 无关 2 ==== 居前 4 ==== 居后 8 ==== 包含 16 ==== 被包含</p><hr><h4 id="4-4-插入文本"><a href="#4-4-插入文本" class="headerlink" title="4.4 插入文本"></a>4.4 插入文本</h4><p>IE的四个属性<br>innerHTML outerHTML 被纳入标准<br>innerText outerText 没有纳入 (操作元素中包含的所有文本内容)</p><ul><li>1.innerText属性</li></ul><p>读取值时： 将子文档树中的所有文本拼接起来<br>写入值时： 删除所有子节点，添加一个子文本节点</p><p>DOM Level 3 规定的textContent属性拥有类似的功能</p><ul><li>2.outerText属性</li></ul><p>读取值时： 与innerText一样<br>写入值时： 删除所有子节点(包括调用节点)，添加一个文本节点 —-相当于 调用节点 替换成 文本节点</p><hr><h4 id="4-5-滚动"><a href="#4-5-滚动" class="headerlink" title="4.5 滚动"></a>4.5 滚动</h4><p>1 scrollIntoView()纳入规范之后，还有几个专有方法可以在不同的浏览器中使用。</p><p>2 scrollIntoViewIfNeeded( alignCenter ) true(视口中部上下垂直)<br>3 scrollByLines( lineCount ) 将元素的内容滚动指定的页面行度<br>4 scrollByPages( pageCount ) 将元素的内容滚动指定的页面高度</p><p>1、2 作用对象是元素的容器，3、4作用对象是元素自身<br>1 唯一一个所有浏览器都支持的方法，最常用的方法</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;DOM扩展&quot;&gt;&lt;a href=&quot;#DOM扩展&quot; class=&quot;headerlink&quot; title=&quot;DOM扩展&quot;&gt;&lt;/a&gt;DOM扩展&lt;/h1&gt;&lt;h
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.heavenbin.live/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript高级程序设计" scheme="http://blog.heavenbin.live/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》第十一章（1）</title>
    <link href="http://blog.heavenbin.live/2017/05/05/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%881%EF%BC%89/"/>
    <id>http://blog.heavenbin.live/2017/05/05/《JavaScript高级程序设计》第十一章（1）/</id>
    <published>2017-05-04T16:00:00.000Z</published>
    <updated>2018-09-02T18:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h1 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h1><p>主要三个扩展： 专有扩展(浏览器自定) + Selectors API(选择符API) + HTML5</p><hr><h2 id="1-选择符API"><a href="#1-选择符API" class="headerlink" title="1 选择符API"></a>1 选择符API</h2><p>Selectors API Level 1的核心：querySeletor()、querySeletorAll()<br>Selectors API Level 2的核心：matchesSelector()</p><hr><h4 id="1-1-querySeletor-方法"><a href="#1-1-querySeletor-方法" class="headerlink" title="1.1 querySeletor()方法"></a>1.1 querySeletor()方法</h4><p>querySelector(CSS选择符) 返回匹配的第一个元素( 空则返回null 仅查找该元素的后代元素 )<br>var myDiv = document.querySelector(“#myDiv”);</p><hr><h4 id="1-2-querySelectorAll-方法"><a href="#1-2-querySelectorAll-方法" class="headerlink" title="1.2 querySelectorAll()方法"></a>1.2 querySelectorAll()方法</h4><p>querySelectorAll(CSS选择符) 返回所有匹配的元素 ( NodeList实例，相当于快照，没有动态 )<br>var strongs = document.querySelectorAll(“p strong”);</p><hr><h4 id="1-3-matchesSelector-方法"><a href="#1-3-matchesSelector-方法" class="headerlink" title="1.3 matchesSelector()方法"></a>1.3 matchesSelector()方法</h4><p>matchesSelector(CSS选择符) 调用元素与该选择符是否匹配(true/false) 2011年年中都还未支持</p><hr><h2 id="2-元素遍历"><a href="#2-元素遍历" class="headerlink" title="2 元素遍历"></a>2 元素遍历</h2><p>之前一些属性会返回文本节点和注释节点。<br>Element Traversal API为DOM元素添加了以下5个属性：<br>childElementCount 返回子元素(不包含文本节点和注释)的个数<br>firstElementChild 指向第一个子元素；firstChild的元素版<br>lastElementChild 指向最后一个子元素；lastChild的元素版<br>previousElementSibling 指向前一个同辈元素；previousSibling的元素版<br>nextElementSibling 指向后一个同辈元素；nextSibling的元素版</p><p>这样遍历NodeList的时候就不用判断是否是元素节点</p><hr><h2 id="3-HTML5"><a href="#3-HTML5" class="headerlink" title="3 HTML5"></a>3 HTML5</h2><p>HTML5围绕如何使用新增标记定义了大量的JS API<br>本章只讲和DOM有关的那部分API。</p><hr><h4 id="3-1-与类-class-相关的扩充"><a href="#3-1-与类-class-相关的扩充" class="headerlink" title="3.1 与类(class)相关的扩充"></a>3.1 与类(class)相关的扩充</h4><p>class属性用的越来越多，用来 给元素添加样式/表示元素的语义</p><ul><li>1.getElementsByClassName()方法<br>getElementsByClassName(一或多个类名字符串) 返回带有指定类的所有元素的NodeList</li></ul><p>document.getElementsByClassName(“username current”)</p><p>document对象调用：返回匹配的所有元素 元素调用：返回匹配的后代元素</p><ul><li>2.classList属性<br>之前className属性是字符串，当需要添加类名的时候，很麻烦(字符串==&gt;数组==&gt;添加)</li></ul><p>classList属性(新集合类型DOMTokenList的实例) 更方便地 添加、删除、替换类名。<br>length 包含多少个类名<br>add(value) 将字符串添加到列表中<br>contains(value) 判断是否存在该字符串<br>remove(value) 删除指定字符串<br>toggle(value) 有则删除，无则添加</p><hr><h4 id="3-2-焦点管理"><a href="#3-2-焦点管理" class="headerlink" title="3.2 焦点管理"></a>3.2 焦点管理</h4><p>document.activeElement 始终会引用DOM中当前获得了焦点的元素。<br>获得焦点的方式：页面加载、用户输入、调用focus()<br>文档加载期间 null<br>文档刚加载完成 document.body</p><p>document.hasFocus() 确定文档是否获得了焦点，可以知道用户是否在交互。</p><hr><h4 id="3-3-HTMLDocument-的变化"><a href="#3-3-HTMLDocument-的变化" class="headerlink" title="3.3 HTMLDocument 的变化"></a>3.3 HTMLDocument 的变化</h4><ul><li><p>1.readyState属性<br>loading 正在加载文档<br>complete 已经加载完文档</p></li><li><p>2.兼容模式 ( compatMode属性 )<br>区分页面的渲染模式<br>CSS1Compat 标准模式<br>BackCompat 混杂模式</p></li><li><p>3.head属性<br>document.head 引用文档的</p><head>元素<p></p></head></li></ul><hr><h4 id="3-4-字符集属性"><a href="#3-4-字符集属性" class="headerlink" title="3.4 字符集属性"></a>3.4 字符集属性</h4><p>charset属性 实际使用的字符集( 默认 UTF-16 )<br>defaultCharset属性 根据操作系统和浏览器设置判断字符集应该是什么</p><p>应用：<br>if(document.charset != document.defaultCharset){<br>alert(“使用的是自定义字符集”);<br>}</p><hr><h4 id="3-5自定义数据属性"><a href="#3-5自定义数据属性" class="headerlink" title="3.5自定义数据属性"></a>3.5自定义数据属性</h4><p>HTML5规定可以为元素添加 非标准的属性 (要添加前缀data-)<br>目的：提供与渲染无关的信息 提供语义信息<br>场景：给元素添加一些不可见的数据以便进行其他处理<br>访问：元素的dataset属性( DOMStringMap的一个实例 )</p><p></p><div id="“myDiv”" data-appid="“12345”"></div><br>var div = document.getElementById(“myDiv”);<br>div.dataset.appId //12345(没有data-)<p></p><hr><h4 id="3-6-插入标记-DOM操作"><a href="#3-6-插入标记-DOM操作" class="headerlink" title="3.6 插入标记(DOM操作)"></a>3.6 插入标记(DOM操作)</h4><p>前面的DOM操作技术非常麻烦</p><ul><li>1.innerHTML属性<br>不支持的元素：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;col&gt; &lt;colgroup&gt; &lt;frameset&gt; &lt;head&gt; &lt;html&gt; &lt;style&gt; </span><br><span class="line">&lt;table&gt; &lt;tbody&gt; &lt;thead&gt; &lt;tfoot&gt; &lt;tr&gt;</span><br></pre></td></tr></table></figure></li></ul><p>读模式：innerHTML返回与调用元素的所有子节点对应的HTML标记<br>写模式：指定值 ==序列化转换==&gt; 新的DOM树 ====&gt; 替换原先的所有子节点</p><p>不同的浏览器 序列化后 返回的结果也不同<br>大多数浏览器通过innerHTML插入script元素并不会执行其中的脚本<br>大多数浏览器都支持以直观的方式通过innerHTML插入style元素</p><p>建议在通过innerHTML插入代码之前，尽可能先手工检查一下其中的文本内容。</p><ul><li>2.outerHTML属性<br>读模式：outerHTML返回调用它的元素及其所有子节点对应的HTML标签<br>写模式：指定HTML字符串 ==序列化转换==&gt; 新的DOM树 ====&gt; 替换调用元素</li></ul><p>不同的浏览器 序列化后 返回的结果也不同</p><ul><li>3.insertAdjacentHTML()方法<br>insertAdjacentHTML() 插入标记</li></ul><p>参数一(插入位置)<br>beforebegin 当前元素 之前 插入 紧邻的同辈元素<br>afterbegin 当前元素 之下 插入 第一个子元素<br>beforeend 当前元素 之下 插入 最后一个子元素<br>afterend 当前元素 之后 插入 紧邻的同辈元素</p><p>参数二(要插入的HTML文本 与innerHTML、outerHTML的值相同)</p><ul><li>4.内存与性能问题<br>内存问题：<br>某个元素 有事件处理程序 或者 引用了其它JS对象作为属性。<br>删除这个元素的话， 和事件处理程序、JS对象的绑定关系并没有一并删除，导致内存积累。<br>建议：先手工删除要被替换的元素的所有事件处理程序和JS对象属性</li></ul><p>性能问题：<br>设置innerHTML/outerHTML时，会创建一个HTML解析器。<br>ul.innerHTML += “</p><li>” + value[i] + “</li>”; //频繁设置会导致性能地下<br>ul.innerHTML = itemsHTML; //一次设置节省性能<br>尽量减少设置innerHTML/outerHTML<p></p><hr><h4 id="3-7-scrollIntoView-方法"><a href="#3-7-scrollIntoView-方法" class="headerlink" title="3.7 scrollIntoView()方法"></a>3.7 scrollIntoView()方法</h4><p>scollIntoView() 方法用于滚动页面 (所有元素都可以调用)</p><p>参数true/不传参 调用元素顶部 与 视口顶部 尽可能平齐<br>参数false 调用元素底部 与 视口底部 尽可能平齐</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;DOM扩展&quot;&gt;&lt;a href=&quot;#DOM扩展&quot; class=&quot;headerlink&quot; title=&quot;DOM扩展&quot;&gt;&lt;/a&gt;DOM扩展&lt;/h1&gt;&lt;p
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.heavenbin.live/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript高级程序设计" scheme="http://blog.heavenbin.live/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》第十章（3）</title>
    <link href="http://blog.heavenbin.live/2017/04/29/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%883%EF%BC%89/"/>
    <id>http://blog.heavenbin.live/2017/04/29/《JavaScript高级程序设计》第十章（3）/</id>
    <published>2017-04-28T16:00:00.000Z</published>
    <updated>2018-09-02T18:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h1 id="DOM-文档对象模型"><a href="#DOM-文档对象模型" class="headerlink" title="DOM(文档对象模型)"></a>DOM(文档对象模型)</h1><h2 id="2-DOM操作技术"><a href="#2-DOM操作技术" class="headerlink" title="2 DOM操作技术"></a>2 DOM操作技术</h2><p>处理DOM充斥着陷阱和不兼容问题。<br>DOM操作往往是JS程序中开销最大的部分，尽量减少DOM操作</p><hr><h4 id="2-1-动态脚本"><a href="#2-1-动态脚本" class="headerlink" title="2.1 动态脚本"></a>2.1 动态脚本</h4><p>动态脚本：在页面加载时不存在，但将来的某一时刻通过修改DOM动态添加的脚本。</p><p>有两种方式：<br>插入外部文件 JS拼凑script标签，需要时添加到body节点尾部<br>直接插入JS代码 需要时添加 文本节点(脚本语句) 到script节点中</p><hr><h4 id="2-2-动态样式"><a href="#2-2-动态样式" class="headerlink" title="2.2 动态样式"></a>2.2 动态样式</h4><p>动态样式：在页面加载完成后动态添加到页面中的样式。<br>link 加入外部文件 JS拼凑link标签，需要时添加到head节点尾部<br>style 加入内嵌样式 需要时添加 文本节点(样式代码) 到style节点中</p><hr><h4 id="2-3-操作表格"><a href="#2-3-操作表格" class="headerlink" title="2.3 操作表格"></a>2.3 操作表格</h4><p><table>都是用DOM操作，懒得看</table></p><hr><h4 id="2-4-使用NodeList"><a href="#2-4-使用NodeList" class="headerlink" title="2.4 使用NodeList"></a>2.4 使用NodeList</h4><p>NodeList NamedNodeMap HTMLCollection 动态的</p><p>对他们进行某些操作的时候，会出现无限循环的状态<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(“div”); </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;divs.length;i++)&#123;                         <span class="comment">//因为length是动态的，所以会无限循环           </span></span><br><span class="line">div = <span class="built_in">document</span>.createElement(“div”);                 <span class="keyword">for</span>(i=<span class="number">0</span>,len=divs.length;i&lt;len;i++)<span class="comment">//可以避免</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>尽量减少访问NodeList的次数</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;DOM-文档对象模型&quot;&gt;&lt;a href=&quot;#DOM-文档对象模型&quot; class=&quot;headerlink&quot; title=&quot;DOM(文档对象模型)&quot;&gt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.heavenbin.live/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript高级程序设计" scheme="http://blog.heavenbin.live/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》第十章（2）</title>
    <link href="http://blog.heavenbin.live/2017/04/25/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%882%EF%BC%89/"/>
    <id>http://blog.heavenbin.live/2017/04/25/《JavaScript高级程序设计》第十章（2）/</id>
    <published>2017-04-24T16:00:00.000Z</published>
    <updated>2018-09-02T18:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h1 id="DOM-文档对象模型"><a href="#DOM-文档对象模型" class="headerlink" title="DOM(文档对象模型)"></a>DOM(文档对象模型)</h1><h2 id="1-节点层次"><a href="#1-节点层次" class="headerlink" title="1 节点层次"></a>1 节点层次</h2><h4 id="1-4-Text类型"><a href="#1-4-Text类型" class="headerlink" title="1.4 Text类型"></a>1.4 Text类型</h4><p>JS通过Text类型 表现 文本节点，包含的 纯文本内容。</p><p>Text 节点特征：<br>nodeType == 3<br>nodeName == “#text”<br>nodeValue == 文本值 == data<br>parentNode == Element<br>没有子节点</p><p>appendData(text) 节点末尾添加text<br>deleteData(offset,count) 从offset位置开始删除count个字符<br>insertData(offset,text) 从offset位置插入text<br>replaceData(offset,count,text) 从offset位置开始替换为text，删除count个字符<br>splitText(offset) 从offset位置将文本节点分成两个文本节点<br>substringData(offset,count) 提取从offset位置开始的count个字符串</p><p>nodeValue.length == data.length == 节点中字符数目</p><p></p><div></div><div></div><div>123123121</div>—- 第二、第三个 都有文本节点<p></p><p>修改文本节点，会自动对文本进行HTML编码( &gt; 变为 &amp;gt )</p><ul><li>1.创建文本节点<br>document.createTextNode(“<strong>hello</strong> word!”);<br>创建文本节点，会自动对文本进行HTML编码( &gt; 变为 &amp;gt )，也会为其设置ownerDocument属性。</li></ul><p>每个元素一般只有一个文本节点，若有多个文本节点且相连的话，那么它们看起来是连起来的。</p><ul><li><p>2.规范化文本节点(合并)<br>一个元素有多个文本子节点会很混乱。<br>element.normalize(); 自动将元素中的所有文本子节点合并</p></li><li><p>3.分割文本节点<br>element.firstChild.splitText(5); 在指定位置分割文本节点，返回后面那个文本节点<br>Hello world! ====&gt; “Hello” “ world!”</p></li></ul><hr><h4 id="1-5-Comment类型"><a href="#1-5-Comment类型" class="headerlink" title="1.5 Comment类型"></a>1.5 Comment类型</h4><p>Comment类型 表现 注释。</p><p>Comment 节点特征：<br>nodeType == 8<br>nodeName == “#comment”<br>nodeValue == 注释值<br>parentNode == Document、Element<br>没有子节点</p><p>与Text类型继承自相同的基类，拥有除splitText()之外的所有字符串操作方法。<br>同样，nodeValue和data包含的是注释的内容<br>document.createComment(“A comment ”); 创建注释节点</p><hr><h4 id="1-6-CDATASection类型"><a href="#1-6-CDATASection类型" class="headerlink" title="1.6 CDATASection类型"></a>1.6 CDATASection类型</h4><p>CDATASection类型 表现CDATA区域(仅XML)<br>继承自Text类型，拥有除splitText()之外的所有字符串操作方法。</p><p>CDATASection 节点特征：<br>nodeType == 4<br>nodeName == “#cdata-section”<br>nodeValue == CDATA区域中的内容<br>parentNode == Document、Element<br>没有子节点</p><p>在XML文档中，document.createCDataSection()创建CDATA区域。</p><hr><h4 id="1-7-DocumentType类型"><a href="#1-7-DocumentType类型" class="headerlink" title="1.7 DocumentType类型"></a>1.7 DocumentType类型</h4><p>DocumentType类型 包含着与文档的doctype有关的所有信息。(支持度不高)</p><p>CDATASection 节点特征：<br>nodeType == 10<br>nodeName == doctype的名称<br>nodeValue == null<br>parentNode == Document<br>没有子节点</p><p>DocumentType对象保存在document.doctype中。<br>三个属性：<br>name 文档类型的名称<br>entities 由文档类型描述的实体的NamedNodeMap对象 (通常空)<br>notations 由文档类型描述的符号的NamedNodeMap对象 (通常空)</p><p>&lt;!DOCTYPE HTML PUBLIC “<del>~~” “</del>~~”&gt;<br>document.doctype.name ===&gt; HTML</p><hr><h4 id="1-8-DocumentFragment类型"><a href="#1-8-DocumentFragment类型" class="headerlink" title="1.8 DocumentFragment类型"></a>1.8 DocumentFragment类型</h4><p>DocumentFragment类型 表示 文档片段，相当于仓库，需要时可以存起来或者取出来。(在文档中没有对应的标记)<br>DocumentFragment节点特征：<br>nodeType == 11<br>nodeName == “#document-fragment”<br>nodeValue == null<br>parentNode == null<br>子节点可能：Element、Text、Comment、ProcessingInstruction、CDATASection、EntityReference</p><p>document.createDocumentFragment() 创建文档片段</p><hr><h4 id="1-9-Attr类型"><a href="#1-9-Attr类型" class="headerlink" title="1.9 Attr类型"></a>1.9 Attr类型</h4><p>Attr类型 表示 元素的特性节点<br>Attr节点特征：<br>nodeType == 2<br>nodeName == 特性的名称<br>nodeValue == 特性的值<br>parentNode == null<br>没有子节点<br>Element类型回顾：<br>Attr节点 相当于 attributes属性<br>使用getAttribute()、setAttribute()、removeAttribut()，而很少直接引用特性节点</p><p>Attr对象三个属性：<br>name 特性名称<br>value 特性值<br>specified 用于设置true指定的/false默认的</p><p>document.createAttribute(“align”); 创建新的特性节点</p><p>element.attributes(“align”).value 返回特性节点<br>element.getAttributeNode(“align”).value 返回特性节点<br>element.getAttribute(“align”); 返回特性值</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;DOM-文档对象模型&quot;&gt;&lt;a href=&quot;#DOM-文档对象模型&quot; class=&quot;headerlink&quot; title=&quot;DOM(文档对象模型)&quot;&gt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.heavenbin.live/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript高级程序设计" scheme="http://blog.heavenbin.live/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》第十章（1）</title>
    <link href="http://blog.heavenbin.live/2017/04/18/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%881%EF%BC%89/"/>
    <id>http://blog.heavenbin.live/2017/04/18/《JavaScript高级程序设计》第十章（1）/</id>
    <published>2017-04-17T16:00:00.000Z</published>
    <updated>2018-09-29T04:42:38.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --><h1 id="DOM-文档对象模型"><a href="#DOM-文档对象模型" class="headerlink" title="DOM(文档对象模型)"></a>DOM(文档对象模型)</h1><p>只讲DOM1级</p><hr><h2 id="1-节点层次"><a href="#1-节点层次" class="headerlink" title="1 节点层次"></a>1 节点层次</h2><p>DOM将HTML/XML文档 描绘成 一个由多层次节点构成的结构<br>有12种节点类型，每种类型表示文档中不同的信息及标记，且有各自的特点、数据和方法。它们都继承自一个基类型。</p><p>文档节点(每个文档的根节点)<br>文档元素(文档节点的唯一子节点，html元素)<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;                 ---- 文档元素        </span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><p></p><hr><h4 id="1-1-Node类型"><a href="#1-1-Node类型" class="headerlink" title="1.1 Node类型"></a>1.1 Node类型</h4><p>DOM1提供Node接口，由DOM中所有节点类型实现。它是在JS中是作为Node类型实现的。</p><p>所有节点类型(12个)都继承自 Node类型 ，它们的nodeType属性表明节点的类型</p><p>Node.ELEMENT_NODE(1); 元素节点(常用) Element类型<br>Node.ATTRIBUTE_NODE(2); 属性节点 Attr类型<br>Node.TEXT_NODE(3); 文本节点(常用) TEXT类型<br>Node.CDATA_SECTION_NODE(4); CDATA节点 CDATASection类型(仅XML文档)<br>Node.ENTITY_REFERENCE_NODE(5); 实体引用名称节点<br>Node.ENTITY_NODE(6); 实体名称节点<br>Node.PROCESSING_INSTRUCTION_NODE(7); 处理指令节点<br>Node.COMMENT_NODE(8); 注释节点 Comment类型<br>Node.DOCUMENT_NODE(9); 文档节点 Document类型<br>Node.DOCUMENT_TYPE_NODE(10); 文档类型节点 DocumentType类型<br>Node.DOCUMENT_FRAGMENT_NODE(11); 文档片段节点 DocumentFragment类型(仅此没对应标记)<br>Node.NOTATION_NODE(12); DTD声明节点</p><ul><li><p>1.nodeName和nodeValue属性<br>不同的节点类型，值也不一样。<br>对于元素节点：nodeName保存标签名，nodeValue保存null。</p></li><li><p>2.节点关系<br>文档树相当于家谱<br>每个节点都有：<br>childNode 所有子节点<br>一个NodeList类数组对象，里面有length属性，DOM结构的变化能够自动反应在这个对象中<br>length属性有些浏览器会计算空白字符。<br>parentNode 父节点<br>firstChild 第一个子节点<br>lastChild 最后一个子节点<br>nextSibling 下一个兄弟节点<br>previousSibling 上一个兄弟节点<br>ownerDocument 指向文档节点 (具有方便性和唯一性)</p></li></ul><p>hasChildNodes() 有一或多个子节点则返回true。(比childNode的length好用)</p><ul><li><p>3.操作节点<br>appendChild(添加节点) 返回添加的节点<br>在子节点末尾添加一个节点(若改节点在childNode中，则是转移效果)<br>insertBefore(插入节点,参照节点) 在参照子节点的前面 插入 节点<br>replaceChild(替换节点,被替换节点) 在被替换子节点处 替换 节点<br>removeChild(移除节点) 移除 指定 子节点</p></li><li><p>4.其它方法<br>cloneNode(true/false) 复制节点(true深复制/false浅复制，不复制JS部分)<br>normalize() 去除后代中的空文本节点，合并相邻的文本节点。</p></li></ul><hr><h4 id="1-2-Document-类型"><a href="#1-2-Document-类型" class="headerlink" title="1.2 Document 类型"></a>1.2 Document 类型</h4><p>JS通过Document类型 表示 文档<br>HTMLDocument类型 继承 Document类型<br>在浏览器中，<br>document对象是HTMLDocument类型的一个实例，表示整个HTML页面。<br>document对象也是window对象的一个属性。<br>功能：取得与页面有关的信息，操作页面的外观及其底层结构。<br>document节点特征：<br>nodeType == 9<br>nodeName == “#document”<br>nodeValue == null<br>parentNode == null<br>ownerDocument == null</p><ul><li>1.文档的子节点<br>子节点可能：<br>DocumentType(&lt;=1) 　　　 &lt;!DOCTYPE&gt; 最多一个文档类型子节点<br>Element(&lt;=1)<html>最多一个元素子节点<br>ProcessingInstruction<br>Comment</html></li></ul><p>一些属性<br>documentElement 访问其子节点的快捷方式 都支持<br>childNodes 访问其子节点的快捷方式 本来就有<br>body 指向</p><body>元素 都支持<br>doctype 指向&lt;!DOCTYPE&gt; 支持不一致，没什么用处<br>位于<html>外的注释 childNodes可以访问 支持不一致，没什么用处<p></p><p>document.documentElement == document.childNodes[0] == document.firstChild</p><p>因为document最多一个元素子节点，所以很少对document进行子节点的操作。</p><ul><li>2.文档信息<br>四个属性(这些值来源于请求的HTTP头部)<br>title 标题<br>URL 完整URL(不可设置) <a href="http://www.wrox.com/WileyCDA/" target="_blank" rel="noopener">http://www.wrox.com/WileyCDA/</a><br>domain 域名(解决跨域问题) <a href="http://www.wrox.com" target="_blank" rel="noopener">www.wrox.com</a> (hostname)<br>referrer 来源页面的URL(不可设置)</li></ul><p>回顾：若页面包含框架(frames)，则每个框架都拥有自己的window对象，并且保存在frames集合中。<br>若 外部(<a href="http://www.wrox.com)内嵌(p2p.wrox.com)" target="_blank" rel="noopener">www.wrox.com)内嵌(p2p.wrox.com)</a> 则无法通信。(跨域安全限制)<br>通过 设置domain = wrox.com ，它们就可以通信了。</p><ul><li>3.查找元素<br>getElementById(元素ID) 返回对应ID的元素 (不存在返回null 区分大小写 多个则取第一个)<br>getElementsByTagName(元素标签名) 返回对应标签名的元素<br>零或多个元素的NodeList类数组对象(HTMLCollection对象) 动态 不区分大小写 *所有元素<br>someNodeList[0] ===&gt; 后台 someNodeList.item(0);<br>someNodeList[“myImage”] ===&gt; 后台 someNodeList.namedItem(“myImage”);</li></ul><p>getElementsByName(元素name特性) 返回对应name的元素 其它情况跟标签名相似</p><ul><li><p>4.特殊集合<br>提供查找元素的快捷方式，都是返回HTMLCollection对象<br>document.anchors 包含文档所有带name特性的<a>元素。<br>document.links 包含文档所有带href特性的<a>元素<br>document.applets 包含文档所有的<applet>元素<br>document.forms document.getElementsByTagName(“from”);<br>document.images document.getElementsByTagName(“img”);</applet></a></a></p></li><li><p>5.DOM一致性检测<br>document.implementation 提供检测浏览器实现了DOM的哪些部分的对象。<br>DOM1提供了一个方法：hasFeature( DOM功能名称 , 版本号 )</p></li></ul><p>var hasXmlDom = document.implementation.hasFeature(“XML”,”1.0”);<br>返回ture则拥有功能，但是未必跟规范一致。建议结合能力检测</p><ul><li>6.文档写入<br>write() 将字符串文本写入到输出流<br>writeln() 将字符串文本写入到输出流 (末尾自动 + \n)<br>open()/close() 打开/关闭 网页的输出流</li></ul><hr><h4 id="1-3-Element类型"><a href="#1-3-Element类型" class="headerlink" title="1.3 Element类型"></a>1.3 Element类型</h4><p>JS通过Element类型 表现XML或HTML元素，提供对元素标签名、子节点及特性的访问。<br>HTMLElement类型 继承 Element类型</p><p>Element 节点特征：<br>nodeType == 1<br>nodeName == 标签名 == tagName(推荐) 值都为大写<br>nodeValue == null<br>parentNode == Document、Element<br>子节点可能：Element、Text、Comment、ProcessingInstruction、CDATASection、EntityReference</p><p>var div = document.getElementById(“myDiv”);<br>div.tagName == div.nodeName == DIV</p><ul><li>1.HTML元素<br>所有的HTML元素 都是 由HTMLElement类型或者其子类型来表示。<br>标准特性：<br>id 唯一标识符<br>title 附加说明信息<br>lang 内容的语言代码<br>dir 语言方向(ltr/rtl)<br>className 指定css类</li></ul><div id="“myDiv”" class="“bd”" title="“Body" text”="" lang="“en”" dir="“ltr”"></div><p>不同的HTML元素对应有不同的类型(书上有表P263)，对应相关的特性和方法。<br>基本所有特性都是属性，但自定义特性不是属性。</p><ul><li>2.取得特性<br>方式一：函数 —- 可以访问自定义特性(data-<em>**</em>)<br>getAttribute() 取得特性 (没有则返回null)</li></ul><p>方式二：属性 —- 不能访问自定义特性，因为没有提供</p><p>两类特殊的特性：<br>style —- 函数访问(返回CSS文本) 属性访问(返回一个对象)<br>onclick —- 函数访问(返回代码字符串) 属性访问(返回一个JS函数)</p><p>结果：开发人员多数都用属性来访问，而函数调用的方式很少使用</p><ul><li>3.设置特性<br>方式一：函数 —- 存在一些异常行为<br>setAttribute() 设置特性 (没有则创建)</li></ul><p>方式二：属性 —- 推荐</p><p>removeAttribute() 彻底删除特性，不常用</p><ul><li>4.attributes属性<br>attributes里面包含一个NamedNodeMap对象 (类似NodeList类数组对象 动态)<br>里面是元素的所有特性节点 (attr节点)<br>每个特性节点： nodeName特性名称 nodeValue特性值</li></ul><p>方法：getNamedItem(name) 返回指定特性节点<br>removeNamedItem(name) 移除节点<br>setNamedItem(node) 添加节点<br>item(pos) 返回位于数字pos位置处的节点<br>这些方法很少用(还不如用前面的)，一般用于遍历特性。</p><ul><li><p>5.创建元素<br>var div = document.createElement(“div”); 创建元素节点(HTML不区分大小写，XML区分大小写)<br>document.body.appendChild(div); 将元素节点添加到body中</p></li><li><p>6.元素的子节点<br>一般都会算空白符，有两种方式去掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方式一：</span><br><span class="line">  &lt;ul&gt;<span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">方式二：  </span><br><span class="line">  element.childNodes[i].nodeType == <span class="number">1</span>  判断它是元素节点</span><br></pre></td></tr></table></figure></li></ul></html></body><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 30 2018 16:39:39 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;DOM-文档对象模型&quot;&gt;&lt;a href=&quot;#DOM-文档对象模型&quot; class=&quot;headerlink&quot; title=&quot;DOM(文档对象模型)&quot;&gt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://blog.heavenbin.live/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript高级程序设计" scheme="http://blog.heavenbin.live/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
